/* tslint:disable */
/* eslint-disable */
/**
 * SweetPotato Server API
 * Sonolusの基本APIを拡張する感じ。 ユーザー認証はFirebaseAuthorizationを通してやる。
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A background provides background graphical element to levels / It defines background used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Background
 * @export
 * @interface Background
 */
export interface Background {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Background
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Background
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Background
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Background
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Background
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    image?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Background
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Background
     */
    description?: string;
}
/**
 * An effect provides audio elements to levels / It defines audio effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Effect
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Effect
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Effect
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Effect
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Effect
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Effect
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    data?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Effect
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Effect
     */
    description?: string;
}
/**
 * An engine provides scripted behaviors to levels / It defines shared game engine for playing https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Engine
 * @export
 * @interface Engine
 */
export interface Engine {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Engine
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Engine
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Engine
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Engine
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Engine
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    configuration?: SonolusResourceLocator;
    /**
     * 
     * @type {Skin}
     * @memberof Engine
     */
    skin?: Skin;
    /**
     * 
     * @type {Background}
     * @memberof Engine
     */
    background?: Background;
    /**
     * 
     * @type {Effect}
     * @memberof Engine
     */
    effect?: Effect;
    /**
     * 
     * @type {Particle}
     * @memberof Engine
     */
    particle?: Particle;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Engine
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Engine
     */
    description?: string;
}
/**
 * Response struct of getBackgroundList
 * @export
 * @interface GetBackgroundListResponse
 */
export interface GetBackgroundListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetBackgroundListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundListResponse
     */
    items: Array<Background>;
}
/**
 * Response struct of getBackground
 * @export
 * @interface GetBackgroundResponse
 */
export interface GetBackgroundResponse {
    /**
     * 
     * @type {Background}
     * @memberof GetBackgroundResponse
     */
    item: Background;
    /**
     * 
     * @type {string}
     * @memberof GetBackgroundResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundResponse
     */
    recommended: Array<Background>;
}
/**
 * Response struct of getEffectList
 * @export
 * @interface GetEffectListResponse
 */
export interface GetEffectListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEffectListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectListResponse
     */
    items: Array<Effect>;
}
/**
 * Response struct of getEffect
 * @export
 * @interface GetEffectResponse
 */
export interface GetEffectResponse {
    /**
     * 
     * @type {Effect}
     * @memberof GetEffectResponse
     */
    item: Effect;
    /**
     * 
     * @type {string}
     * @memberof GetEffectResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectResponse
     */
    recommended: Array<Effect>;
}
/**
 * Response struct of getEngineList
 * @export
 * @interface GetEngineListResponse
 */
export interface GetEngineListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEngineListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineListResponse
     */
    items: Array<Engine>;
}
/**
 * Response struct of getEngine
 * @export
 * @interface GetEngineResponse
 */
export interface GetEngineResponse {
    /**
     * 
     * @type {Engine}
     * @memberof GetEngineResponse
     */
    item: Engine;
    /**
     * 
     * @type {string}
     * @memberof GetEngineResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineResponse
     */
    recommended: Array<Engine>;
}
/**
 * Response struct of getLevelList
 * @export
 * @interface GetLevelListResponse
 */
export interface GetLevelListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetLevelListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelListResponse
     */
    items: Array<Level>;
}
/**
 * Response struct of getLevel
 * @export
 * @interface GetLevelResponse
 */
export interface GetLevelResponse {
    /**
     * 
     * @type {Level}
     * @memberof GetLevelResponse
     */
    item: Level;
    /**
     * 
     * @type {string}
     * @memberof GetLevelResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelResponse
     */
    recommended: Array<Level>;
}
/**
 * Response struct of getParticleList
 * @export
 * @interface GetParticleListResponse
 */
export interface GetParticleListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetParticleListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleListResponse
     */
    items: Array<Particle>;
}
/**
 * Response struct of getParticle
 * @export
 * @interface GetParticleResponse
 */
export interface GetParticleResponse {
    /**
     * 
     * @type {Particle}
     * @memberof GetParticleResponse
     */
    item: Particle;
    /**
     * 
     * @type {string}
     * @memberof GetParticleResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleResponse
     */
    recommended: Array<Particle>;
}
/**
 * Response struct of getSkinList
 * @export
 * @interface GetSkinListResponse
 */
export interface GetSkinListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetSkinListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinListResponse
     */
    items: Array<Skin>;
}
/**
 * Response struct of getSkin
 * @export
 * @interface GetSkinResponse
 */
export interface GetSkinResponse {
    /**
     * 
     * @type {Skin}
     * @memberof GetSkinResponse
     */
    item: Skin;
    /**
     * 
     * @type {string}
     * @memberof GetSkinResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinResponse
     */
    recommended: Array<Skin>;
}
/**
 * Structure of getList response
 * @export
 * @interface GetUserListResponse
 */
export interface GetUserListResponse {
    /**
     * サーバーに登録されたユーザー一覧
     * @type {Array<User>}
     * @memberof GetUserListResponse
     */
    users: Array<User>;
    /**
     * 合計アカウント数
     * @type {number}
     * @memberof GetUserListResponse
     */
    total: number;
    /**
     * 合計ページ数
     * @type {number}
     * @memberof GetUserListResponse
     */
    pages: number;
}
/**
 * A level provides a list of entities and powered by scripted behavior in engine, with skin, effect, background and particle, to create gameplay experience for players / It defines level for actual user play. It includes all data to play one level. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Level
 * @export
 * @interface Level
 */
export interface Level {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Level
     */
    name: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Level
     */
    version: number;
    /**
     * Difficulty of the level
     * @type {number}
     * @memberof Level
     */
    rating: number;
    /**
     * Just a name of engine (Sonolus-express finds the engine from db)
     * @type {string}
     * @memberof Level
     */
    engine: string;
    /**
     * 
     * @type {LevelUseSkin}
     * @memberof Level
     */
    useSkin?: LevelUseSkin;
    /**
     * 
     * @type {LevelUseBackground}
     * @memberof Level
     */
    useBackground?: LevelUseBackground;
    /**
     * 
     * @type {LevelUseEffect}
     * @memberof Level
     */
    useEffect?: LevelUseEffect;
    /**
     * 
     * @type {LevelUseParticle}
     * @memberof Level
     */
    useParticle?: LevelUseParticle;
    /**
     * 
     * @type {LocalizationText}
     * @memberof Level
     */
    title: LocalizationText;
    /**
     * 
     * @type {LocalizationText}
     * @memberof Level
     */
    artists: LocalizationText;
    /**
     * 
     * @type {LocalizationText}
     * @memberof Level
     */
    author: LocalizationText;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    cover: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    bgm: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    data: SonolusResourceLocator;
    /**
     * 独自要素: 楽曲のジャンル
     * @type {string}
     * @memberof Level
     */
    genre: string;
    /**
     * 独自要素: 楽曲が全体公開かどうか
     * @type {boolean}
     * @memberof Level
     */
    _public?: boolean;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Level
     */
    userId?: string;
    /**
     * 独自要素: 譜面内のノーツ数
     * @type {number}
     * @memberof Level
     */
    notes?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    updatedTime?: number;
    /**
     * 
     * @type {LocalizationText}
     * @memberof Level
     */
    description: LocalizationText;
    /**
     * 独自要素: サムネのハッシュ値(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    coverHash?: string;
    /**
     * 独自要素: データのハッシュ(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    dataHash?: string;
    /**
     * 独自要素: BGMのハッシュ(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    bgmHash?: string;
    /**
     * 独自要素: プレイされた回数
     * @type {number}
     * @memberof Level
     */
    playCount?: number;
}
/**
 * 
 * @export
 * @interface LevelUseBackground
 */
export interface LevelUseBackground {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseBackground
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Background}
     * @memberof LevelUseBackground
     */
    item?: Background;
}
/**
 * 
 * @export
 * @interface LevelUseEffect
 */
export interface LevelUseEffect {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseEffect
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Effect}
     * @memberof LevelUseEffect
     */
    item?: Effect;
}
/**
 * 
 * @export
 * @interface LevelUseParticle
 */
export interface LevelUseParticle {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseParticle
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Particle}
     * @memberof LevelUseParticle
     */
    item?: Particle;
}
/**
 * 
 * @export
 * @interface LevelUseSkin
 */
export interface LevelUseSkin {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseSkin
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Skin}
     * @memberof LevelUseSkin
     */
    item?: Skin;
}
/**
 * 
 * @export
 * @interface LocalizationText
 */
export interface LocalizationText {
    /**
     * Simplified Chinese
     * @type {string}
     * @memberof LocalizationText
     */
    cn?: string;
    /**
     * TraditionalChinese
     * @type {string}
     * @memberof LocalizationText
     */
    tw?: string;
    /**
     * Japanese
     * @type {string}
     * @memberof LocalizationText
     */
    ja: string;
    /**
     * English
     * @type {string}
     * @memberof LocalizationText
     */
    en?: string;
    /**
     * Korean
     * @type {string}
     * @memberof LocalizationText
     */
    ko?: string;
    /**
     * Indonesian
     * @type {string}
     * @memberof LocalizationText
     */
    id?: string;
    /**
     * Spanish
     * @type {string}
     * @memberof LocalizationText
     */
    es?: string;
}
/**
 * A particle provides particle effect elements to levels / It defines particle effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Particle
 * @export
 * @interface Particle
 */
export interface Particle {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Particle
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Particle
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Particle
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Particle
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Particle
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Particle
     */
    userId?: string;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Particle
     */
    description?: string;
}
/**
 * Response / Request struct of getServerInfo
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {Array<Level>}
     * @memberof ServerInfo
     */
    levels: Array<Level>;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof ServerInfo
     */
    skins: Array<Skin>;
    /**
     * 
     * @type {Array<Background>}
     * @memberof ServerInfo
     */
    backgrounds: Array<Background>;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof ServerInfo
     */
    effects: Array<Effect>;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof ServerInfo
     */
    particles: Array<Particle>;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof ServerInfo
     */
    engines: Array<Engine>;
}
/**
 * A skin provides graphic elements to levels / It defines graphics for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Skin https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Server
 * @export
 * @interface Skin
 */
export interface Skin {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Skin
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Skin
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Skin
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Skin
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Skin
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Skin
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Skin
     */
    description?: string;
}
/**
 * Sonolus Resource Locator(SRL) is used in server endpoints in order for Sonolus to locate a resource. All resources must be gzip compressed. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Resource-and-SRL
 * @export
 * @interface SonolusResourceLocator
 */
export interface SonolusResourceLocator {
    /**
     * When specify type together with hash uniquely identifies a resource.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    type?: SonolusResourceLocatorTypeEnum;
    /**
     * Hash is calculated using SHA1 on the resource file
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    hash?: string;
    /**
     * If url starts with character /, it will be treated as relative path to server address.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SonolusResourceLocatorTypeEnum {
    SkinData = 'SkinData',
    EngineThumbnail = 'EngineThumbnail',
    EffectData = 'EffectData',
    SkinTexture = 'SkinTexture',
    ParticleData = 'ParticleData',
    EffectThumbnail = 'EffectThumbnail',
    LevelBgm = 'LevelBgm',
    BackgroundThumbnail = 'BackgroundThumbnail',
    EngineConfiguration = 'EngineConfiguration',
    LevelData = 'LevelData',
    ParticleTexture = 'ParticleTexture',
    BackgroundData = 'BackgroundData',
    EngineData = 'EngineData',
    BackgroundImage = 'BackgroundImage',
    LevelCover = 'LevelCover',
    SkinThumbnail = 'SkinThumbnail',
    ParticleThumbnail = 'ParticleThumbnail'
}

/**
 * ユーザー情報型
 * @export
 * @interface User
 */
export interface User {
    /**
     * FirebaseDatabase上のユーザーID
     * @type {string}
     * @memberof User
     */
    userId?: string;
    /**
     * テスト用サーバーのエンドポイント
     * @type {string}
     * @memberof User
     */
    testId?: string;
    /**
     * 管理者か否か
     * @type {boolean}
     * @memberof User
     */
    isAdmin?: boolean;
    /**
     * アカウント削除フラグ(trueで削除済み扱い)
     * @type {boolean}
     * @memberof User
     */
    isDeleted?: boolean;
    /**
     * トータル譜面数
     * @type {number}
     * @memberof User
     */
    totalFumen?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof User
     */
    description?: string;
}

/**
 * BackgroundsApi - axios parameter creator
 * @export
 */
export const BackgroundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground: async (backgroundName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('getBackground', 'backgroundName', backgroundName)
            const localVarPath = `/backgrounds/{backgroundName}`
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/backgrounds/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackgroundsApi - functional programming interface
 * @export
 */
export const BackgroundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackgroundsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackground(backgroundName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackground(backgroundName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackgroundList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackgroundsApi - factory interface
 * @export
 */
export const BackgroundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackgroundsApiFp(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground(backgroundName: string, localization?: string, options?: any): AxiosPromise<GetBackgroundResponse> {
            return localVarFp.getBackground(backgroundName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetBackgroundListResponse> {
            return localVarFp.getBackgroundList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackgroundsApi - object-oriented interface
 * @export
 * @class BackgroundsApi
 * @extends {BaseAPI}
 */
export class BackgroundsApi extends BaseAPI {
    /**
     * It returns specified background info It will raise 404 if the background is not registered in this server
     * @summary Get background
     * @param {string} backgroundName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackground(backgroundName: string, localization?: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackground(backgroundName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of background infos registered in this server Also it can search using query params
     * @summary Get background list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackgroundList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect: async (effectName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('getEffect', 'effectName', effectName)
            const localVarPath = `/effects/{effectName}`
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/effects/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffect(effectName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffect(effectName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffectList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffectList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect(effectName: string, localization?: string, options?: any): AxiosPromise<GetEffectResponse> {
            return localVarFp.getEffect(effectName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEffectListResponse> {
            return localVarFp.getEffectList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * It returns specified effect info It will raise 404 if the effect is not registered in this server
     * @summary Get effect
     * @param {string} effectName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffect(effectName: string, localization?: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffect(effectName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of effect infos registered in this server Also it can search using query params
     * @summary Get effect list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffectList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffectList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine: async (engineName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('getEngine', 'engineName', engineName)
            const localVarPath = `/engines/{engineName}`
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/engines/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnginesApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngine(engineName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngine(engineName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngineList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngineList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnginesApi - factory interface
 * @export
 */
export const EnginesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnginesApiFp(configuration)
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine(engineName: string, localization?: string, options?: any): AxiosPromise<GetEngineResponse> {
            return localVarFp.getEngine(engineName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEngineListResponse> {
            return localVarFp.getEngineList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnginesApi - object-oriented interface
 * @export
 * @class EnginesApi
 * @extends {BaseAPI}
 */
export class EnginesApi extends BaseAPI {
    /**
     * It returns specified engine info It will raise 404 if the engine is not registered in this server
     * @summary Get engine
     * @param {string} engineName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngine(engineName: string, localization?: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngine(engineName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of engine infos registered in this server Also it can search using query params
     * @summary Get engine list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngineList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngineList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (localization?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getServerInfo(localization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
     * @summary Get server info
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getServerInfo(localization?: string, options?: any) {
        return InfoApiFp(this.configuration).getServerInfo(localization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LevelsApi - axios parameter creator
 * @export
 */
export const LevelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('addLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('editLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel: async (levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/levels/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LevelsApi - functional programming interface
 * @export
 */
export const LevelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LevelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevel(levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevel(levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LevelsApi - factory interface
 * @export
 */
export const LevelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LevelsApiFp(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.addLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.editLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel(levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevel(levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getLevelList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LevelsApi - object-oriented interface
 * @export
 * @class LevelsApi
 * @extends {BaseAPI}
 */
export class LevelsApi extends BaseAPI {
    /**
     * 指定された譜面情報をサーバーに登録します
     * @summary Add level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public addLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).addLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたlevelを編集します
     * @summary Edit level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public editLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).editLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get level
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevel(levelName: string, localization?: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevel(levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of level infos registered in this server Also it can search using query params
     * @summary Get level list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevelList(localization?: string, page?: number, keywords?: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevelList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParticlesApi - axios parameter creator
 * @export
 */
export const ParticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle: async (particleName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('getParticle', 'particleName', particleName)
            const localVarPath = `/particles/{particleName}`
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/particles/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticlesApi - functional programming interface
 * @export
 */
export const ParticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticle(particleName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticle(particleName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticleList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticleList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParticlesApi - factory interface
 * @export
 */
export const ParticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticlesApiFp(configuration)
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle(particleName: string, localization?: string, options?: any): AxiosPromise<GetParticleResponse> {
            return localVarFp.getParticle(particleName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetParticleListResponse> {
            return localVarFp.getParticleList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticlesApi - object-oriented interface
 * @export
 * @class ParticlesApi
 * @extends {BaseAPI}
 */
export class ParticlesApi extends BaseAPI {
    /**
     * It returns specified particle info It will raise 404 if the particle is not registered in this server
     * @summary Get particle
     * @param {string} particleName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticle(particleName: string, localization?: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticle(particleName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of particle infos registered in this server Also it can search using query params
     * @summary Get particle list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticleList(localization?: string, page?: number, keywords?: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticleList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundConfiguration: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryBackgroundConfiguration', 'resourceName', resourceName)
            const localVarPath = `/repository/BackgroundConfiguration/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryBackgroundData', 'resourceName', resourceName)
            const localVarPath = `/repository/BackgroundData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundImage: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryBackgroundImage', 'resourceName', resourceName)
            const localVarPath = `/repository/BackgroundImage/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundThumbnail: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryBackgroundThumbnail', 'resourceName', resourceName)
            const localVarPath = `/repository/BackgroundThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectClip: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEffectClip', 'resourceName', resourceName)
            const localVarPath = `/repository/EffectClip/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returnes specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEffectData', 'resourceName', resourceName)
            const localVarPath = `/repository/EffectData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectThumbnail: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEffectThumbnail', 'resourceName', resourceName)
            const localVarPath = `/repository/EffectThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineConfiguration: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEngineConfiguration', 'resourceName', resourceName)
            const localVarPath = `/repository/EngineConfiguration/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEngineData', 'resourceName', resourceName)
            const localVarPath = `/repository/EngineData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineThumbnail: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryEngineThumbnail', 'resourceName', resourceName)
            const localVarPath = `/repository/EngineThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelBgm: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryLevelBgm', 'resourceName', resourceName)
            const localVarPath = `/repository/LevelBgm/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelCover: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryLevelCover', 'resourceName', resourceName)
            const localVarPath = `/repository/LevelCover/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryLevelData', 'resourceName', resourceName)
            const localVarPath = `/repository/LevelData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryParticleData', 'resourceName', resourceName)
            const localVarPath = `/repository/ParticleData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleTexture: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryParticleTexture', 'resourceName', resourceName)
            const localVarPath = `/repository/ParticleTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleThumbnail: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositoryParticleThumbnail', 'resourceName', resourceName)
            const localVarPath = `/repository/ParticleThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelBgm: async (levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getRepositoryPathLevelBgm', 'levelName', levelName)
            const localVarPath = `/repository/{levelName}/bgm.mp3`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelCover: async (levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getRepositoryPathLevelCover', 'levelName', levelName)
            const localVarPath = `/repository/{levelName}/cover.png`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelData: async (levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getRepositoryPathLevelData', 'levelName', levelName)
            const localVarPath = `/repository/{levelName}/data.gz`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinData: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositorySkinData', 'resourceName', resourceName)
            const localVarPath = `/repository/SkinData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinTexture: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositorySkinTexture', 'resourceName', resourceName)
            const localVarPath = `/repository/SkinTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinThumbnail: async (resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getRepositorySkinThumbnail', 'resourceName', resourceName)
            const localVarPath = `/repository/SkinThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundConfiguration: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundConfiguration', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundConfiguration', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/BackgroundConfiguration/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/BackgroundData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundImage: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundImage', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundImage', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/BackgroundImage/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundThumbnail: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundThumbnail', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryBackgroundThumbnail', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/BackgroundThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectClip: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEffectClip', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEffectClip', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EffectClip/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEffectData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEffectData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EffectData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectThumbnail: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEffectThumbnail', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEffectThumbnail', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EffectThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineConfiguration: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEngineConfiguration', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEngineConfiguration', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EngineConfiguration/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEngineData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEngineData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EngineData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineThumbnail: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryEngineThumbnail', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryEngineThumbnail', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/EngineThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelBgm: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryLevelBgm', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryLevelBgm', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/LevelBgm/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelCover: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryLevelCover', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryLevelCover', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/LevelCover/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryLevelData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryLevelData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/LevelData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryParticleData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryParticleData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/ParticleData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleTexture: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryParticleTexture', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryParticleTexture', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/ParticleTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleThumbnail: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositoryParticleThumbnail', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryParticleThumbnail', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/ParticleThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelBgm: async (testId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelBgm', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelBgm', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/repository/{levelName}/bgm.mp3`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelCover: async (testId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelCover', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelCover', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/repository/{levelName}/cover.png`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelData: async (testId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelData', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getTestRepositoryPathLevelData', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/repository/{levelName}/data.gz`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinData: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositorySkinData', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositorySkinData', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/SkinData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinTexture: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositorySkinTexture', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositorySkinTexture', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/SkinTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinThumbnail: async (resourceName: string, testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getTestRepositorySkinThumbnail', 'resourceName', resourceName)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestRepositorySkinThumbnail', 'testId', testId)
            const localVarPath = `/tests/{testId}/repository/SkinThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} userId 
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundConfiguration: async (userId: string, resourceName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundConfiguration', 'userId', userId)
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundConfiguration', 'resourceName', resourceName)
            const localVarPath = `/users/{userId}/repository/BackgroundConfiguration/{resourceName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/BackgroundData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundImage: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundImage', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundImage', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/BackgroundImage/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundThumbnail: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundThumbnail', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryBackgroundThumbnail', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/BackgroundThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectClip: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEffectClip', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEffectClip', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EffectClip/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEffectData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEffectData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EffectData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectThumbnail: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEffectThumbnail', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEffectThumbnail', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EffectThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineConfiguration: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEngineConfiguration', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEngineConfiguration', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EngineConfiguration/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEngineData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEngineData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EngineData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineThumbnail: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryEngineThumbnail', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryEngineThumbnail', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/EngineThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelBgm: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryLevelBgm', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryLevelBgm', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/LevelBgm/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelCover: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryLevelCover', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryLevelCover', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/LevelCover/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryLevelData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryLevelData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/LevelData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryParticleData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryParticleData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/ParticleData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleTexture: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryParticleTexture', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryParticleTexture', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/ParticleTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleThumbnail: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositoryParticleThumbnail', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryParticleThumbnail', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/ParticleThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelBgm: async (userId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelBgm', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelBgm', 'levelName', levelName)
            const localVarPath = `/users/{userId}/repository/{levelName}/bgm.mp3`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelCover: async (userId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelCover', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelCover', 'levelName', levelName)
            const localVarPath = `/users/{userId}/repository/{levelName}/cover.png`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelData: async (userId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelData', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUserRepositoryPathLevelData', 'levelName', levelName)
            const localVarPath = `/users/{userId}/repository/{levelName}/data.gz`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinData: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositorySkinData', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositorySkinData', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/SkinData/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinTexture: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositorySkinTexture', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositorySkinTexture', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/SkinTexture/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinThumbnail: async (resourceName: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('getUserRepositorySkinThumbnail', 'resourceName', resourceName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRepositorySkinThumbnail', 'userId', userId)
            const localVarPath = `/users/{userId}/repository/SkinThumbnail/{resourceName}`
                .replace(`{${"resourceName"}}`, encodeURIComponent(String(resourceName)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryBackgroundConfiguration(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryBackgroundConfiguration(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryBackgroundData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryBackgroundData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryBackgroundImage(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryBackgroundImage(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryBackgroundThumbnail(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryBackgroundThumbnail(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEffectClip(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEffectClip(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returnes specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEffectData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEffectData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEffectThumbnail(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEffectThumbnail(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEngineConfiguration(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEngineConfiguration(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEngineData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEngineData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryEngineThumbnail(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryEngineThumbnail(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryLevelBgm(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryLevelBgm(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryLevelCover(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryLevelCover(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryLevelData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryLevelData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryParticleData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryParticleData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryParticleTexture(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryParticleTexture(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryParticleThumbnail(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryParticleThumbnail(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPathLevelBgm(levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPathLevelBgm(levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPathLevelCover(levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPathLevelCover(levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryPathLevelData(levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryPathLevelData(levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositorySkinData(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositorySkinData(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositorySkinTexture(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositorySkinTexture(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositorySkinThumbnail(resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositorySkinThumbnail(resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryBackgroundConfiguration(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryBackgroundConfiguration(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryBackgroundData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryBackgroundData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryBackgroundImage(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryBackgroundImage(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryBackgroundThumbnail(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryBackgroundThumbnail(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEffectClip(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEffectClip(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEffectData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEffectData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEffectThumbnail(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEffectThumbnail(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEngineConfiguration(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEngineConfiguration(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEngineData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEngineData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryEngineThumbnail(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryEngineThumbnail(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryLevelBgm(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryLevelBgm(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryLevelCover(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryLevelCover(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryLevelData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryLevelData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryParticleData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryParticleData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryParticleTexture(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryParticleTexture(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryParticleThumbnail(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryParticleThumbnail(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryPathLevelBgm(testId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryPathLevelBgm(testId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryPathLevelCover(testId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryPathLevelCover(testId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositoryPathLevelData(testId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositoryPathLevelData(testId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositorySkinData(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositorySkinData(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositorySkinTexture(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositorySkinTexture(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRepositorySkinThumbnail(resourceName: string, testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRepositorySkinThumbnail(resourceName, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} userId 
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryBackgroundConfiguration(userId: string, resourceName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryBackgroundConfiguration(userId, resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryBackgroundData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryBackgroundData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryBackgroundImage(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryBackgroundImage(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryBackgroundThumbnail(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryBackgroundThumbnail(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEffectClip(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEffectClip(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEffectData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEffectData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEffectThumbnail(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEffectThumbnail(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEngineConfiguration(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEngineConfiguration(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEngineData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEngineData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryEngineThumbnail(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryEngineThumbnail(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryLevelBgm(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryLevelBgm(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryLevelCover(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryLevelCover(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryLevelData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryLevelData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryParticleData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryParticleData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryParticleTexture(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryParticleTexture(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryParticleThumbnail(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryParticleThumbnail(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryPathLevelBgm(userId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryPathLevelBgm(userId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryPathLevelCover(userId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryPathLevelCover(userId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositoryPathLevelData(userId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositoryPathLevelData(userId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositorySkinData(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositorySkinData(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositorySkinTexture(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositorySkinTexture(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepositorySkinThumbnail(resourceName: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepositorySkinThumbnail(resourceName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundConfiguration(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryBackgroundConfiguration(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryBackgroundData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundImage(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryBackgroundImage(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryBackgroundThumbnail(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryBackgroundThumbnail(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectClip(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEffectClip(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returnes specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEffectData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEffectThumbnail(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEffectThumbnail(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineConfiguration(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEngineConfiguration(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEngineData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryEngineThumbnail(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryEngineThumbnail(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelBgm(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryLevelBgm(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelCover(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryLevelCover(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryLevelData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryLevelData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryParticleData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleTexture(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryParticleTexture(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryParticleThumbnail(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryParticleThumbnail(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelBgm(levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryPathLevelBgm(levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelCover(levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryPathLevelCover(levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryPathLevelData(levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositoryPathLevelData(levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinData(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositorySkinData(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinTexture(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositorySkinTexture(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositorySkinThumbnail(resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepositorySkinThumbnail(resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundConfiguration(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryBackgroundConfiguration(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryBackgroundData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundImage(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryBackgroundImage(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryBackgroundThumbnail(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryBackgroundThumbnail(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectClip(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEffectClip(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEffectData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEffectThumbnail(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEffectThumbnail(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineConfiguration(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEngineConfiguration(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEngineData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryEngineThumbnail(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryEngineThumbnail(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelBgm(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryLevelBgm(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelCover(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryLevelCover(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryLevelData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryLevelData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryParticleData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleTexture(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryParticleTexture(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryParticleThumbnail(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryParticleThumbnail(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelBgm(testId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryPathLevelBgm(testId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelCover(testId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryPathLevelCover(testId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositoryPathLevelData(testId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositoryPathLevelData(testId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinData(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositorySkinData(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinTexture(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositorySkinTexture(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRepositorySkinThumbnail(resourceName: string, testId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTestRepositorySkinThumbnail(resourceName, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundConfiguration
         * @param {string} userId 
         * @param {string} resourceName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundConfiguration(userId: string, resourceName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryBackgroundConfiguration(userId, resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryBackgroundData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundImage
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundImage(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryBackgroundImage(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetBackgroundThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryBackgroundThumbnail(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryBackgroundThumbnail(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectClip
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectClip(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEffectClip(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEffectData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEffectThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEffectThumbnail(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEffectThumbnail(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineConfiguration
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineConfiguration(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEngineConfiguration(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEngineData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetEngineThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryEngineThumbnail(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryEngineThumbnail(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelBgm
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelBgm(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryLevelBgm(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelCover
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelCover(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryLevelCover(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetLevelData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryLevelData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryLevelData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryParticleData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleTexture(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryParticleTexture(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetParticleThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryParticleThumbnail(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryParticleThumbnail(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelBgm
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelBgm(userId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryPathLevelBgm(userId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelCover
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelCover(userId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryPathLevelCover(userId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary Get levelData
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositoryPathLevelData(userId: string, levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositoryPathLevelData(userId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinData
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinData(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositorySkinData(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinTexture
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinTexture(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositorySkinTexture(resourceName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It return specified resource data.
         * @summary GetSkinThumbnail
         * @param {string} resourceName 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepositorySkinThumbnail(resourceName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserRepositorySkinThumbnail(resourceName, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * It return specified resource data.
     * @summary GetBackgroundConfiguration
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryBackgroundConfiguration(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryBackgroundConfiguration(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryBackgroundData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryBackgroundData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundImage
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryBackgroundImage(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryBackgroundImage(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundThumbnail
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryBackgroundThumbnail(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryBackgroundThumbnail(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectClip
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEffectClip(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEffectClip(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returnes specified resource data.
     * @summary GetEffectData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEffectData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEffectData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectThumbnail
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEffectThumbnail(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEffectThumbnail(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineConfiguration
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEngineConfiguration(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEngineConfiguration(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEngineData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEngineData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineThumbnail
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryEngineThumbnail(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryEngineThumbnail(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelBgm
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryLevelBgm(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryLevelBgm(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelCover
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryLevelCover(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryLevelCover(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryLevelData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryLevelData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryParticleData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryParticleData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleTexture
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryParticleTexture(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryParticleTexture(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleThumbnail
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryParticleThumbnail(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryParticleThumbnail(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelBgm
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryPathLevelBgm(levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryPathLevelBgm(levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelCover
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryPathLevelCover(levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryPathLevelCover(levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelData
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryPathLevelData(levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositoryPathLevelData(levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinData
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositorySkinData(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositorySkinData(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinTexture
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositorySkinTexture(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositorySkinTexture(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinThumbnail
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositorySkinThumbnail(resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepositorySkinThumbnail(resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundConfiguration
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryBackgroundConfiguration(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryBackgroundConfiguration(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryBackgroundData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryBackgroundData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundImage
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryBackgroundImage(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryBackgroundImage(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundThumbnail
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryBackgroundThumbnail(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryBackgroundThumbnail(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectClip
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEffectClip(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEffectClip(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEffectData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEffectData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectThumbnail
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEffectThumbnail(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEffectThumbnail(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineConfiguration
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEngineConfiguration(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEngineConfiguration(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEngineData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEngineData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineThumbnail
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryEngineThumbnail(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryEngineThumbnail(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelBgm
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryLevelBgm(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryLevelBgm(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelCover
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryLevelCover(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryLevelCover(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryLevelData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryLevelData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryParticleData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryParticleData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleTexture
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryParticleTexture(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryParticleTexture(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleThumbnail
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryParticleThumbnail(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryParticleThumbnail(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelBgm
     * @param {string} testId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryPathLevelBgm(testId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryPathLevelBgm(testId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelCover
     * @param {string} testId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryPathLevelCover(testId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryPathLevelCover(testId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelData
     * @param {string} testId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositoryPathLevelData(testId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositoryPathLevelData(testId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinData
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositorySkinData(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositorySkinData(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinTexture
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositorySkinTexture(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositorySkinTexture(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinThumbnail
     * @param {string} resourceName 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTestRepositorySkinThumbnail(resourceName: string, testId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getTestRepositorySkinThumbnail(resourceName, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundConfiguration
     * @param {string} userId 
     * @param {string} resourceName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryBackgroundConfiguration(userId: string, resourceName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryBackgroundConfiguration(userId, resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryBackgroundData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryBackgroundData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundImage
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryBackgroundImage(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryBackgroundImage(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetBackgroundThumbnail
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryBackgroundThumbnail(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryBackgroundThumbnail(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectClip
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEffectClip(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEffectClip(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEffectData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEffectData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEffectThumbnail
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEffectThumbnail(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEffectThumbnail(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineConfiguration
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEngineConfiguration(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEngineConfiguration(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEngineData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEngineData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetEngineThumbnail
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryEngineThumbnail(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryEngineThumbnail(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelBgm
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryLevelBgm(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryLevelBgm(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelCover
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryLevelCover(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryLevelCover(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetLevelData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryLevelData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryLevelData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryParticleData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryParticleData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleTexture
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryParticleTexture(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryParticleTexture(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetParticleThumbnail
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryParticleThumbnail(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryParticleThumbnail(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelBgm
     * @param {string} userId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryPathLevelBgm(userId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryPathLevelBgm(userId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelCover
     * @param {string} userId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryPathLevelCover(userId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryPathLevelCover(userId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary Get levelData
     * @param {string} userId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositoryPathLevelData(userId: string, levelName: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositoryPathLevelData(userId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinData
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositorySkinData(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositorySkinData(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinTexture
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositorySkinTexture(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositorySkinTexture(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It return specified resource data.
     * @summary GetSkinThumbnail
     * @param {string} resourceName 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getUserRepositorySkinThumbnail(resourceName: string, userId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getUserRepositorySkinThumbnail(resourceName, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SkinsApi - axios parameter creator
 * @export
 */
export const SkinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin: async (skinName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('getSkin', 'skinName', skinName)
            const localVarPath = `/skins/{skinName}`
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/skins/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkinsApi - functional programming interface
 * @export
 */
export const SkinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkinsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkin(skinName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkin(skinName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkinList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkinList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SkinsApi - factory interface
 * @export
 */
export const SkinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkinsApiFp(configuration)
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin(skinName: string, localization?: string, options?: any): AxiosPromise<GetSkinResponse> {
            return localVarFp.getSkin(skinName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetSkinListResponse> {
            return localVarFp.getSkinList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkinsApi - object-oriented interface
 * @export
 * @class SkinsApi
 * @extends {BaseAPI}
 */
export class SkinsApi extends BaseAPI {
    /**
     * It returns specified skin info It will raise 404 if the skin is not registered in this server
     * @summary Get skin
     * @param {string} skinName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkin(skinName: string, localization?: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkin(skinName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of skin infos registered in this server Also it can search using query params
     * @summary Get skin list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkinList(localization?: string, page?: number, keywords?: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkinList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestsApi - axios parameter creator
 * @export
 */
export const TestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest: async (testId: string, levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getLevelTest', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevelTest', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/levels/{levelName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo: async (testId: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestServerInfo', 'testId', testId)
            const localVarPath = `/tests/{testId}/info`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsLevels', 'testId', testId)
            const localVarPath = `/tests/{testId}/levels/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestsApi - functional programming interface
 * @export
 */
export const TestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelTest(testId: string, levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelTest(testId, levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestServerInfo(testId: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestServerInfo(testId, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsLevels(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestsApi - factory interface
 * @export
 */
export const TestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestsApiFp(configuration)
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest(testId: string, levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevelTest(testId, levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo(testId: string, localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getTestServerInfo(testId, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getTestsLevels(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestsApi - object-oriented interface
 * @export
 * @class TestsApi
 * @extends {BaseAPI}
 */
export class TestsApi extends BaseAPI {
    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get testing level
     * @param {string} testId 
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getLevelTest(testId: string, levelName: string, localization?: string, options?: any) {
        return TestsApiFp(this.configuration).getLevelTest(testId, levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * テスト個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestServerInfo(testId: string, localization?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestServerInfo(testId, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsLevels(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 独自要素
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 独自要素
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * 独自要素
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * 独自要素
     * @summary Upload file
     * @param {any} [file] ファイル本体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public uploadFile(file?: any, options?: any) {
        return UploadsApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (userId: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo: async (userId: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserServerInfo', 'userId', userId)
            const localVarPath = `/users/{userId}/info`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel: async (userId: string, levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevel', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUsersLevel', 'levelName', levelName)
            const localVarPath = `/users/{userId}/levels/{levelName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevels', 'userId', userId)
            const localVarPath = `/users/{userId}/levels/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(userId: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserServerInfo(userId: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserServerInfo(userId, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevel(userId: string, levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevel(userId, levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevels(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId: string, user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.editUser(userId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList(options?: any): AxiosPromise<GetUserListResponse> {
            return localVarFp.getUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo(userId: string, localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getUserServerInfo(userId, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel(userId: string, levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getUsersLevel(userId, levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getUsersLevels(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 指定したuser情報を編集します
     * @summary Edit user
     * @param {string} userId 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editUser(userId: string, user?: User, options?: any) {
        return UsersApiFp(this.configuration).editUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したユーザー情報を取得します
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * サーバーに登録されたユーザー一覧を返します
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserList(options?: any) {
        return UsersApiFp(this.configuration).getUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserServerInfo(userId: string, localization?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserServerInfo(userId, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get users level
     * @param {string} userId 
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevel(userId: string, levelName: string, localization?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevel(userId, levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevels(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


