/* tslint:disable */
/* eslint-disable */
/**
 * SweetPotato Server 2 API
 * Advanced Sonolus API server with adds minimum features (TypeScript)   Development repository is [here](https://github.com/PurplePalette/sonolus-uploader-core2)  ### Sonolus-Version - 0.5.9  ### Features - supports uploading level - tests server for chart testing - simple upload endpoint  ### Original comments - Sonolusの基本APIを拡張する感じのAPI(Sonolus-Express) - ユーザー認証はFirebaseAuthorizationを通してやる。 - データベースはファイル構造そのまま
 *
 * The version of the OpenAPI document: 0.5.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A background provides background graphical element to levels / It defines background used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Background
 * @export
 * @interface Background
 */
export interface Background {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Background
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Background
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Background
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Background
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Background
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    image?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Background
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Background
     */
    description?: string;
}
/**
 * An effect provides audio elements to levels / It defines audio effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Effect
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Effect
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Effect
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Effect
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Effect
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Effect
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    data?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Effect
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Effect
     */
    description?: string;
}
/**
 * An engine provides scripted behaviors to levels / It defines shared game engine for playing https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Engine
 * @export
 * @interface Engine
 */
export interface Engine {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Engine
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Engine
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Engine
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Engine
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Engine
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    configuration?: SonolusResourceLocator;
    /**
     * 
     * @type {Skin}
     * @memberof Engine
     */
    skin?: Skin;
    /**
     * 
     * @type {Background}
     * @memberof Engine
     */
    background?: Background;
    /**
     * 
     * @type {Effect}
     * @memberof Engine
     */
    effect?: Effect;
    /**
     * 
     * @type {Particle}
     * @memberof Engine
     */
    particle?: Particle;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Engine
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Engine
     */
    description?: string;
}
/**
 * Response struct of getBackgroundList
 * @export
 * @interface GetBackgroundListResponse
 */
export interface GetBackgroundListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetBackgroundListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundListResponse
     */
    items: Array<Background>;
}
/**
 * Response struct of getBackground
 * @export
 * @interface GetBackgroundResponse
 */
export interface GetBackgroundResponse {
    /**
     * 
     * @type {Background}
     * @memberof GetBackgroundResponse
     */
    item: Background;
    /**
     * 
     * @type {string}
     * @memberof GetBackgroundResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundResponse
     */
    recommended: Array<Background>;
}
/**
 * Response struct of getEffectList
 * @export
 * @interface GetEffectListResponse
 */
export interface GetEffectListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEffectListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectListResponse
     */
    items: Array<Effect>;
}
/**
 * Response struct of getEffect
 * @export
 * @interface GetEffectResponse
 */
export interface GetEffectResponse {
    /**
     * 
     * @type {Effect}
     * @memberof GetEffectResponse
     */
    item: Effect;
    /**
     * 
     * @type {string}
     * @memberof GetEffectResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectResponse
     */
    recommended: Array<Effect>;
}
/**
 * Response struct of getEngineList
 * @export
 * @interface GetEngineListResponse
 */
export interface GetEngineListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEngineListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineListResponse
     */
    items: Array<Engine>;
}
/**
 * Response struct of getEngine
 * @export
 * @interface GetEngineResponse
 */
export interface GetEngineResponse {
    /**
     * 
     * @type {Engine}
     * @memberof GetEngineResponse
     */
    item: Engine;
    /**
     * 
     * @type {string}
     * @memberof GetEngineResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineResponse
     */
    recommended: Array<Engine>;
}
/**
 * Response struct of getLevelList
 * @export
 * @interface GetLevelListResponse
 */
export interface GetLevelListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetLevelListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelListResponse
     */
    items: Array<Level>;
}
/**
 * Response struct of getLevel
 * @export
 * @interface GetLevelResponse
 */
export interface GetLevelResponse {
    /**
     * 
     * @type {Level}
     * @memberof GetLevelResponse
     */
    item: Level;
    /**
     * 
     * @type {string}
     * @memberof GetLevelResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelResponse
     */
    recommended: Array<Level>;
}
/**
 * Response struct of getParticleList
 * @export
 * @interface GetParticleListResponse
 */
export interface GetParticleListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetParticleListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleListResponse
     */
    items: Array<Particle>;
}
/**
 * Response struct of getParticle
 * @export
 * @interface GetParticleResponse
 */
export interface GetParticleResponse {
    /**
     * 
     * @type {Particle}
     * @memberof GetParticleResponse
     */
    item: Particle;
    /**
     * 
     * @type {string}
     * @memberof GetParticleResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleResponse
     */
    recommended: Array<Particle>;
}
/**
 * Response struct of getSkinList
 * @export
 * @interface GetSkinListResponse
 */
export interface GetSkinListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetSkinListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinListResponse
     */
    items: Array<Skin>;
}
/**
 * Response struct of getSkin
 * @export
 * @interface GetSkinResponse
 */
export interface GetSkinResponse {
    /**
     * 
     * @type {Skin}
     * @memberof GetSkinResponse
     */
    item: Skin;
    /**
     * 
     * @type {string}
     * @memberof GetSkinResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinResponse
     */
    recommended: Array<Skin>;
}
/**
 * Structure of getList response
 * @export
 * @interface GetUserListResponse
 */
export interface GetUserListResponse {
    /**
     * サーバーに登録されたユーザー一覧
     * @type {Array<User>}
     * @memberof GetUserListResponse
     */
    users: Array<User>;
    /**
     * 合計アカウント数
     * @type {number}
     * @memberof GetUserListResponse
     */
    total: number;
    /**
     * 合計ページ数
     * @type {number}
     * @memberof GetUserListResponse
     */
    pages: number;
}
/**
 * A level provides a list of entities and powered by scripted behavior in engine, with skin, effect, background and particle, to create gameplay experience for players / It defines level for actual user play. It includes all data to play one level. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Level
 * @export
 * @interface Level
 */
export interface Level {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Level
     */
    name: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Level
     */
    version: number;
    /**
     * Difficulty of the level
     * @type {number}
     * @memberof Level
     */
    rating: number;
    /**
     * Just a name of engine (Sonolus-express finds the engine from db)
     * @type {string | Engine}
     * @memberof Level
     */
    engine?: string | Engine;
    /**
     * 
     * @type {LevelUseSkin}
     * @memberof Level
     */
    useSkin?: LevelUseSkin;
    /**
     * 
     * @type {LevelUseBackground}
     * @memberof Level
     */
    useBackground?: LevelUseBackground;
    /**
     * 
     * @type {LevelUseEffect}
     * @memberof Level
     */
    useEffect?: LevelUseEffect;
    /**
     * 
     * @type {LevelUseParticle}
     * @memberof Level
     */
    useParticle?: LevelUseParticle;
    /**
     * 
     * @type {string | LocalizationText}
     * @memberof Level
     */
    title?: string | LocalizationText;
    /**
     * 
     * @type {string | LocalizationText}
     * @memberof Level
     */
    artists: string | LocalizationText;
    /**
     * 
     * @type {string | LocalizationText}
     * @memberof Level
     */
    author: string | LocalizationText;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    cover: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    bgm: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    data: SonolusResourceLocator;
    /**
     * 独自要素: 楽曲のジャンル
     * @type {string}
     * @memberof Level
     */
    genre: string;
    /**
     * 独自要素: 楽曲が全体公開かどうか
     * @type {boolean}
     * @memberof Level
     */
    public?: boolean;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Level
     */
    userId?: string;
    /**
     * 独自要素: 譜面内のノーツ数
     * @type {number}
     * @memberof Level
     */
    notes?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    updatedTime?: number;
    /**
     * 
     * @type {string | LocalizationText}
     * @memberof Level
     */
    description: string | LocalizationText;
    /**
     * 独自要素: サムネのハッシュ値(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    coverHash?: string;
    /**
     * 独自要素: データのハッシュ(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    dataHash?: string;
    /**
     * 独自要素: BGMのハッシュ(DBを兼ねるため)
     * @type {string}
     * @memberof Level
     */
    bgmHash?: string;
    /**
     * 独自要素: プレイされた回数
     * @type {number}
     * @memberof Level
     */
    playCount?: number;
}
/**
 * 
 * @export
 * @interface LevelUseBackground
 */
export interface LevelUseBackground {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseBackground
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Background}
     * @memberof LevelUseBackground
     */
    item?: Background;
}
/**
 * 
 * @export
 * @interface LevelUseEffect
 */
export interface LevelUseEffect {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseEffect
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Effect}
     * @memberof LevelUseEffect
     */
    item?: Effect;
}
/**
 * 
 * @export
 * @interface LevelUseParticle
 */
export interface LevelUseParticle {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseParticle
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Particle}
     * @memberof LevelUseParticle
     */
    item?: Particle;
}
/**
 * 
 * @export
 * @interface LevelUseSkin
 */
export interface LevelUseSkin {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseSkin
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Skin}
     * @memberof LevelUseSkin
     */
    item?: Skin;
}
/**
 * 
 * @export
 * @interface LocalizationText
 */
export interface LocalizationText {
    /**
     * Simplified Chinese
     * @type {string}
     * @memberof LocalizationText
     */
    cn?: string;
    /**
     * TraditionalChinese
     * @type {string}
     * @memberof LocalizationText
     */
    tw?: string;
    /**
     * Japanese
     * @type {string}
     * @memberof LocalizationText
     */
    ja: string;
    /**
     * English
     * @type {string}
     * @memberof LocalizationText
     */
    en?: string;
    /**
     * Korean
     * @type {string}
     * @memberof LocalizationText
     */
    ko?: string;
    /**
     * Indonesian
     * @type {string}
     * @memberof LocalizationText
     */
    id?: string;
    /**
     * Spanish
     * @type {string}
     * @memberof LocalizationText
     */
    es?: string;
}
/**
 * A particle provides particle effect elements to levels / It defines particle effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Particle
 * @export
 * @interface Particle
 */
export interface Particle {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Particle
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Particle
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Particle
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Particle
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Particle
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Particle
     */
    userId?: string;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Particle
     */
    description?: string;
}
/**
 * Structure of post upload response
 * @export
 * @interface PostUploadResponse
 */
export interface PostUploadResponse {
    /**
     * Response status in human readable
     * @type {string}
     * @memberof PostUploadResponse
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PostUploadResponse
     */
    filename?: string;
}
/**
 * Response / Request struct of getServerInfo
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {Array<Level>}
     * @memberof ServerInfo
     */
    levels: Array<Level>;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof ServerInfo
     */
    skins: Array<Skin>;
    /**
     * 
     * @type {Array<Background>}
     * @memberof ServerInfo
     */
    backgrounds: Array<Background>;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof ServerInfo
     */
    effects: Array<Effect>;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof ServerInfo
     */
    particles: Array<Particle>;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof ServerInfo
     */
    engines: Array<Engine>;
}
/**
 * A skin provides graphic elements to levels / It defines graphics for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Skin https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Server
 * @export
 * @interface Skin
 */
export interface Skin {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Skin
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Skin
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Skin
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Skin
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Skin
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Skin
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Skin
     */
    description?: string;
}
/**
 * Sonolus Resource Locator(SRL) is used in server endpoints in order for Sonolus to locate a resource. All resources must be gzip compressed. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Resource-and-SRL
 * @export
 * @interface SonolusResourceLocator
 */
export interface SonolusResourceLocator {
    /**
     * When specify type together with hash uniquely identifies a resource.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    type?: SonolusResourceLocatorTypeEnum;
    /**
     * Hash is calculated using SHA1 on the resource file
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    hash?: string;
    /**
     * If url starts with character /, it will be treated as relative path to server address.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SonolusResourceLocatorTypeEnum {
    SkinData = 'SkinData',
    EngineThumbnail = 'EngineThumbnail',
    EffectData = 'EffectData',
    SkinTexture = 'SkinTexture',
    ParticleData = 'ParticleData',
    EffectThumbnail = 'EffectThumbnail',
    LevelBgm = 'LevelBgm',
    BackgroundThumbnail = 'BackgroundThumbnail',
    EngineConfiguration = 'EngineConfiguration',
    LevelData = 'LevelData',
    ParticleTexture = 'ParticleTexture',
    BackgroundData = 'BackgroundData',
    EngineData = 'EngineData',
    BackgroundImage = 'BackgroundImage',
    LevelCover = 'LevelCover',
    SkinThumbnail = 'SkinThumbnail',
    ParticleThumbnail = 'ParticleThumbnail'
}

/**
 * ユーザー情報型
 * @export
 * @interface User
 */
export interface User {
    /**
     * FirebaseDatabase上のユーザーID
     * @type {string}
     * @memberof User
     */
    userId?: string;
    /**
     * テスト用サーバーのエンドポイント
     * @type {string}
     * @memberof User
     */
    testId?: string;
    /**
     * 管理者か否か
     * @type {boolean}
     * @memberof User
     */
    isAdmin?: boolean;
    /**
     * アカウント削除フラグ(trueで削除済み扱い)
     * @type {boolean}
     * @memberof User
     */
    isDeleted?: boolean;
    /**
     * トータル譜面数
     * @type {number}
     * @memberof User
     */
    totalFumen?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof User
     */
    description?: string;
}

/**
 * BackgroundsApi - axios parameter creator
 * @export
 */
export const BackgroundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground: async (backgroundName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('getBackground', 'backgroundName', backgroundName)
            const localVarPath = `/backgrounds/{backgroundName}`
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/backgrounds/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackgroundsApi - functional programming interface
 * @export
 */
export const BackgroundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackgroundsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackground(backgroundName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackground(backgroundName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackgroundList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackgroundsApi - factory interface
 * @export
 */
export const BackgroundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackgroundsApiFp(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground(backgroundName: string, localization?: string, options?: any): AxiosPromise<GetBackgroundResponse> {
            return localVarFp.getBackground(backgroundName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetBackgroundListResponse> {
            return localVarFp.getBackgroundList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackgroundsApi - object-oriented interface
 * @export
 * @class BackgroundsApi
 * @extends {BaseAPI}
 */
export class BackgroundsApi extends BaseAPI {
    /**
     * It returns specified background info It will raise 404 if the background is not registered in this server
     * @summary Get background
     * @param {string} backgroundName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackground(backgroundName: string, localization?: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackground(backgroundName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of background infos registered in this server Also it can search using query params
     * @summary Get background list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackgroundList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect: async (effectName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('getEffect', 'effectName', effectName)
            const localVarPath = `/effects/{effectName}`
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/effects/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffect(effectName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffect(effectName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffectList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffectList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect(effectName: string, localization?: string, options?: any): AxiosPromise<GetEffectResponse> {
            return localVarFp.getEffect(effectName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEffectListResponse> {
            return localVarFp.getEffectList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * It returns specified effect info It will raise 404 if the effect is not registered in this server
     * @summary Get effect
     * @param {string} effectName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffect(effectName: string, localization?: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffect(effectName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of effect infos registered in this server Also it can search using query params
     * @summary Get effect list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffectList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffectList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine: async (engineName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('getEngine', 'engineName', engineName)
            const localVarPath = `/engines/{engineName}`
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/engines/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnginesApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngine(engineName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngine(engineName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngineList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngineList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnginesApi - factory interface
 * @export
 */
export const EnginesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnginesApiFp(configuration)
    return {
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine(engineName: string, localization?: string, options?: any): AxiosPromise<GetEngineResponse> {
            return localVarFp.getEngine(engineName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEngineListResponse> {
            return localVarFp.getEngineList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnginesApi - object-oriented interface
 * @export
 * @class EnginesApi
 * @extends {BaseAPI}
 */
export class EnginesApi extends BaseAPI {
    /**
     * It returns specified engine info It will raise 404 if the engine is not registered in this server
     * @summary Get engine
     * @param {string} engineName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngine(engineName: string, localization?: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngine(engineName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of engine infos registered in this server Also it can search using query params
     * @summary Get engine list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngineList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngineList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (localization?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getServerInfo(localization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
     * @summary Get server info
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getServerInfo(localization?: string, options?: any) {
        return InfoApiFp(this.configuration).getServerInfo(localization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LevelsApi - axios parameter creator
 * @export
 */
export const LevelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('addLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたlevelを削除します
         * @summary Delete Level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLevel: async (levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('deleteLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('editLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel: async (levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/levels/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LevelsApi - functional programming interface
 * @export
 */
export const LevelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LevelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたlevelを削除します
         * @summary Delete Level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLevel(levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLevel(levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevel(levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevel(levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LevelsApi - factory interface
 * @export
 */
export const LevelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LevelsApiFp(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.addLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたlevelを削除します
         * @summary Delete Level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLevel(levelName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLevel(levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.editLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel(levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevel(levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getLevelList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LevelsApi - object-oriented interface
 * @export
 * @class LevelsApi
 * @extends {BaseAPI}
 */
export class LevelsApi extends BaseAPI {
    /**
     * 指定された譜面情報をサーバーに登録します
     * @summary Add level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public addLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).addLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたlevelを削除します
     * @summary Delete Level
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public deleteLevel(levelName: string, options?: any) {
        return LevelsApiFp(this.configuration).deleteLevel(levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたlevelを編集します
     * @summary Edit level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public editLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).editLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get level
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevel(levelName: string, localization?: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevel(levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of level infos registered in this server Also it can search using query params
     * @summary Get level list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevelList(localization?: string, page?: number, keywords?: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevelList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParticlesApi - axios parameter creator
 * @export
 */
export const ParticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle: async (particleName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('getParticle', 'particleName', particleName)
            const localVarPath = `/particles/{particleName}`
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/particles/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticlesApi - functional programming interface
 * @export
 */
export const ParticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticle(particleName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticle(particleName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticleList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticleList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParticlesApi - factory interface
 * @export
 */
export const ParticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticlesApiFp(configuration)
    return {
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle(particleName: string, localization?: string, options?: any): AxiosPromise<GetParticleResponse> {
            return localVarFp.getParticle(particleName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetParticleListResponse> {
            return localVarFp.getParticleList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticlesApi - object-oriented interface
 * @export
 * @class ParticlesApi
 * @extends {BaseAPI}
 */
export class ParticlesApi extends BaseAPI {
    /**
     * It returns specified particle info It will raise 404 if the particle is not registered in this server
     * @summary Get particle
     * @param {string} particleName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticle(particleName: string, localization?: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticle(particleName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of particle infos registered in this server Also it can search using query params
     * @summary Get particle list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticleList(localization?: string, page?: number, keywords?: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticleList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returnes specified resource data.
         * @summary GetRepository
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository: async (path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getRepository', 'path', path)
            const localVarPath = `/repository/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * It returnes specified resource data.
         * @summary GetRepository
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepository(path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepository(path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * It returnes specified resource data.
         * @summary GetRepository
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository(path: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRepository(path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * It returnes specified resource data.
     * @summary GetRepository
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepository(path: string, options?: any) {
        return RepositoryApiFp(this.configuration).getRepository(path, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SkinsApi - axios parameter creator
 * @export
 */
export const SkinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin: async (skinName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('getSkin', 'skinName', skinName)
            const localVarPath = `/skins/{skinName}`
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/skins/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkinsApi - functional programming interface
 * @export
 */
export const SkinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkinsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkin(skinName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkin(skinName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkinList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkinList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SkinsApi - factory interface
 * @export
 */
export const SkinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkinsApiFp(configuration)
    return {
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin(skinName: string, localization?: string, options?: any): AxiosPromise<GetSkinResponse> {
            return localVarFp.getSkin(skinName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetSkinListResponse> {
            return localVarFp.getSkinList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkinsApi - object-oriented interface
 * @export
 * @class SkinsApi
 * @extends {BaseAPI}
 */
export class SkinsApi extends BaseAPI {
    /**
     * It returns specified skin info It will raise 404 if the skin is not registered in this server
     * @summary Get skin
     * @param {string} skinName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkin(skinName: string, localization?: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkin(skinName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of skin infos registered in this server Also it can search using query params
     * @summary Get skin list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkinList(localization?: string, page?: number, keywords?: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkinList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestsApi - axios parameter creator
 * @export
 */
export const TestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest: async (testId: string, levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getLevelTest', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevelTest', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/levels/{levelName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo: async (testId: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestServerInfo', 'testId', testId)
            const localVarPath = `/tests/{testId}/info`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsLevels', 'testId', testId)
            const localVarPath = `/tests/{testId}/levels/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestsApi - functional programming interface
 * @export
 */
export const TestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelTest(testId: string, levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelTest(testId, levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestServerInfo(testId: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestServerInfo(testId, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsLevels(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestsApi - factory interface
 * @export
 */
export const TestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestsApiFp(configuration)
    return {
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest(testId: string, levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevelTest(testId, levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo(testId: string, localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getTestServerInfo(testId, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getTestsLevels(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestsApi - object-oriented interface
 * @export
 * @class TestsApi
 * @extends {BaseAPI}
 */
export class TestsApi extends BaseAPI {
    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get testing level
     * @param {string} testId 
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getLevelTest(testId: string, levelName: string, localization?: string, options?: any) {
        return TestsApiFp(this.configuration).getLevelTest(testId, levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * テスト個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestServerInfo(testId: string, localization?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestServerInfo(testId, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsLevels(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ファイルのアップロードを受け付ける (投稿から1時間以上使用されないファイルは自動削除したい)
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * ファイルのアップロードを受け付ける (投稿から1時間以上使用されないファイルは自動削除したい)
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * ファイルのアップロードを受け付ける (投稿から1時間以上使用されないファイルは自動削除したい)
         * @summary Upload file
         * @param {any} [file] ファイル本体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: any, options?: any): AxiosPromise<PostUploadResponse> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * ファイルのアップロードを受け付ける (投稿から1時間以上使用されないファイルは自動削除したい)
     * @summary Upload file
     * @param {any} [file] ファイル本体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public uploadFile(file?: any, options?: any) {
        return UploadsApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (userId: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo: async (userId: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserServerInfo', 'userId', userId)
            const localVarPath = `/users/{userId}/info`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel: async (userId: string, levelName: string, localization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevel', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUsersLevel', 'levelName', levelName)
            const localVarPath = `/users/{userId}/levels/{levelName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevels', 'userId', userId)
            const localVarPath = `/users/{userId}/levels/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(userId: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserServerInfo(userId: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserServerInfo(userId, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevel(userId: string, levelName: string, localization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevel(userId, levelName, localization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevels(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId: string, user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.editUser(userId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList(options?: any): AxiosPromise<GetUserListResponse> {
            return localVarFp.getUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo(userId: string, localization?: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getUserServerInfo(userId, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {string} [localization] It localizes response items if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel(userId: string, levelName: string, localization?: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getUsersLevel(userId, levelName, localization, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getUsersLevels(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 指定したuser情報を編集します
     * @summary Edit user
     * @param {string} userId 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editUser(userId: string, user?: User, options?: any) {
        return UsersApiFp(this.configuration).editUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したユーザー情報を取得します
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * サーバーに登録されたユーザー一覧を返します
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserList(options?: any) {
        return UsersApiFp(this.configuration).getUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserServerInfo(userId: string, localization?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserServerInfo(userId, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get users level
     * @param {string} userId 
     * @param {string} levelName 
     * @param {string} [localization] It localizes response items if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevel(userId: string, levelName: string, localization?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevel(userId, levelName, localization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevels(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


