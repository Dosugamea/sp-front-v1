/* tslint:disable */
/* eslint-disable */
/**
 * SweetPotato Server API
 * Sonolusの基本APIを拡張する感じ。 ユーザー認証はFirebaseAuthorizationを通してやる。
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A background provides background graphical element to levels / It defines background used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Background
 * @export
 * @interface Background
 */
export interface Background {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Background
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Background
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Background
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Background
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Background
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Background
     */
    image?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Background
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Background
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Background
     */
    description?: string;
}
/**
 * An effect provides audio elements to levels / It defines audio effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Effect
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Effect
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Effect
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Effect
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Effect
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Effect
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Effect
     */
    data?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Effect
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Effect
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Effect
     */
    description?: string;
}
/**
 * An engine provides scripted behaviors to levels / It defines shared game engine for playing https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Engine
 * @export
 * @interface Engine
 */
export interface Engine {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Engine
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Engine
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Engine
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Engine
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Engine
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Engine
     */
    configuration?: SonolusResourceLocator;
    /**
     * 
     * @type {Skin}
     * @memberof Engine
     */
    skin?: Skin;
    /**
     * 
     * @type {Background}
     * @memberof Engine
     */
    background?: Background;
    /**
     * 
     * @type {Effect}
     * @memberof Engine
     */
    effect?: Effect;
    /**
     * 
     * @type {Particle}
     * @memberof Engine
     */
    particle?: Particle;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Engine
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Engine
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Engine
     */
    description?: string;
}
/**
 * Response struct of getBackgroundList
 * @export
 * @interface GetBackgroundListResponse
 */
export interface GetBackgroundListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetBackgroundListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundListResponse
     */
    items: Array<Background>;
}
/**
 * Response struct of getBackground
 * @export
 * @interface GetBackgroundResponse
 */
export interface GetBackgroundResponse {
    /**
     * 
     * @type {Background}
     * @memberof GetBackgroundResponse
     */
    item: Background;
    /**
     * 
     * @type {string}
     * @memberof GetBackgroundResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Background>}
     * @memberof GetBackgroundResponse
     */
    recommended: Array<Background>;
}
/**
 * Response struct of getEffectList
 * @export
 * @interface GetEffectListResponse
 */
export interface GetEffectListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEffectListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectListResponse
     */
    items: Array<Effect>;
}
/**
 * Response struct of getEffect
 * @export
 * @interface GetEffectResponse
 */
export interface GetEffectResponse {
    /**
     * 
     * @type {Effect}
     * @memberof GetEffectResponse
     */
    item: Effect;
    /**
     * 
     * @type {string}
     * @memberof GetEffectResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof GetEffectResponse
     */
    recommended: Array<Effect>;
}
/**
 * Response struct of getEngineList
 * @export
 * @interface GetEngineListResponse
 */
export interface GetEngineListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetEngineListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineListResponse
     */
    items: Array<Engine>;
}
/**
 * Response struct of getEngine
 * @export
 * @interface GetEngineResponse
 */
export interface GetEngineResponse {
    /**
     * 
     * @type {Engine}
     * @memberof GetEngineResponse
     */
    item: Engine;
    /**
     * 
     * @type {string}
     * @memberof GetEngineResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof GetEngineResponse
     */
    recommended: Array<Engine>;
}
/**
 * Response struct of getLevelList
 * @export
 * @interface GetLevelListResponse
 */
export interface GetLevelListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetLevelListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelListResponse
     */
    items: Array<Level>;
}
/**
 * Response struct of getLevel
 * @export
 * @interface GetLevelResponse
 */
export interface GetLevelResponse {
    /**
     * 
     * @type {Level}
     * @memberof GetLevelResponse
     */
    item: Level;
    /**
     * 
     * @type {string}
     * @memberof GetLevelResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Level>}
     * @memberof GetLevelResponse
     */
    recommended: Array<Level>;
}
/**
 * Response struct of getParticleList
 * @export
 * @interface GetParticleListResponse
 */
export interface GetParticleListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetParticleListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleListResponse
     */
    items: Array<Particle>;
}
/**
 * Response struct of getParticle
 * @export
 * @interface GetParticleResponse
 */
export interface GetParticleResponse {
    /**
     * 
     * @type {Particle}
     * @memberof GetParticleResponse
     */
    item: Particle;
    /**
     * 
     * @type {string}
     * @memberof GetParticleResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof GetParticleResponse
     */
    recommended: Array<Particle>;
}
/**
 * Response struct of getSkinList
 * @export
 * @interface GetSkinListResponse
 */
export interface GetSkinListResponse {
    /**
     * used for pagination, default is 1
     * @type {number}
     * @memberof GetSkinListResponse
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinListResponse
     */
    items: Array<Skin>;
}
/**
 * Response struct of getSkin
 * @export
 * @interface GetSkinResponse
 */
export interface GetSkinResponse {
    /**
     * 
     * @type {Skin}
     * @memberof GetSkinResponse
     */
    item: Skin;
    /**
     * 
     * @type {string}
     * @memberof GetSkinResponse
     */
    description: string;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof GetSkinResponse
     */
    recommended: Array<Skin>;
}
/**
 * Structure of getList response
 * @export
 * @interface GetUserListResponse
 */
export interface GetUserListResponse {
    /**
     * サーバーに登録されたユーザー一覧
     * @type {Array<User>}
     * @memberof GetUserListResponse
     */
    users: Array<User>;
    /**
     * 合計アカウント数
     * @type {number}
     * @memberof GetUserListResponse
     */
    total: number;
    /**
     * 合計ページ数
     * @type {number}
     * @memberof GetUserListResponse
     */
    pages: number;
}
/**
 * A level provides a list of entities and powered by scripted behavior in engine, with skin, effect, background and particle, to create gameplay experience for players / It defines level for actual user play. It includes all data to play one level. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Level
 * @export
 * @interface Level
 */
export interface Level {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Level
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Level
     */
    version?: number;
    /**
     * Difficulty of the level
     * @type {number}
     * @memberof Level
     */
    rating?: number;
    /**
     * 
     * @type {Engine}
     * @memberof Level
     */
    engine?: Engine;
    /**
     * 
     * @type {LevelUseSkin}
     * @memberof Level
     */
    useSkin?: LevelUseSkin;
    /**
     * 
     * @type {LevelUseBackground}
     * @memberof Level
     */
    useBackground?: LevelUseBackground;
    /**
     * 
     * @type {LevelUseEffect}
     * @memberof Level
     */
    useEffect?: LevelUseEffect;
    /**
     * 
     * @type {LevelUseParticle}
     * @memberof Level
     */
    useParticle?: LevelUseParticle;
    /**
     * base title of this content
     * @type {string}
     * @memberof Level
     */
    title?: string;
    /**
     * artist names of original music
     * @type {string}
     * @memberof Level
     */
    artists?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Level
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    cover?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    bgm?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Level
     */
    data?: SonolusResourceLocator;
    /**
     * 独自要素: 楽曲のジャンル
     * @type {string}
     * @memberof Level
     */
    genre?: LevelGenreEnum;
    /**
     * 独自要素: 楽曲が全体公開かどうか
     * @type {boolean}
     * @memberof Level
     */
    _public?: boolean;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Level
     */
    userId?: string;
    /**
     * 独自要素: 譜面内のノーツ数
     * @type {number}
     * @memberof Level
     */
    notes?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Level
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Level
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LevelGenreEnum {
    General = 'general',
    Jpop = 'jpop',
    Anime = 'anime',
    Vocaloid = 'vocaloid'
}

/**
 * 
 * @export
 * @interface LevelUseBackground
 */
export interface LevelUseBackground {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseBackground
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Background}
     * @memberof LevelUseBackground
     */
    item?: Background;
}
/**
 * 
 * @export
 * @interface LevelUseEffect
 */
export interface LevelUseEffect {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseEffect
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Effect}
     * @memberof LevelUseEffect
     */
    item?: Effect;
}
/**
 * 
 * @export
 * @interface LevelUseParticle
 */
export interface LevelUseParticle {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseParticle
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Particle}
     * @memberof LevelUseParticle
     */
    item?: Particle;
}
/**
 * 
 * @export
 * @interface LevelUseSkin
 */
export interface LevelUseSkin {
    /**
     * If true (recommended), default resource specified by the engine will be used.
     * @type {boolean}
     * @memberof LevelUseSkin
     */
    useDefault?: boolean;
    /**
     * 
     * @type {Skin}
     * @memberof LevelUseSkin
     */
    item?: Skin;
}
/**
 * A particle provides particle effect elements to levels / It defines particle effect used for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Particle
 * @export
 * @interface Particle
 */
export interface Particle {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Particle
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Particle
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Particle
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Particle
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Particle
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Particle
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Particle
     */
    userId?: string;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Particle
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Particle
     */
    description?: string;
}
/**
 * Response / Request struct of getServerInfo
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {Array<Level>}
     * @memberof ServerInfo
     */
    levels: Array<Level>;
    /**
     * 
     * @type {Array<Skin>}
     * @memberof ServerInfo
     */
    skins: Array<Skin>;
    /**
     * 
     * @type {Array<Background>}
     * @memberof ServerInfo
     */
    backgrounds: Array<Background>;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof ServerInfo
     */
    effects: Array<Effect>;
    /**
     * 
     * @type {Array<Particle>}
     * @memberof ServerInfo
     */
    particles: Array<Particle>;
    /**
     * 
     * @type {Array<Engine>}
     * @memberof ServerInfo
     */
    engines: Array<Engine>;
}
/**
 * A skin provides graphic elements to levels / It defines graphics for specific level https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Skin https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Server
 * @export
 * @interface Skin
 */
export interface Skin {
    /**
     * english and number only name for searching
     * @type {string}
     * @memberof Skin
     */
    name?: string;
    /**
     * Reserved for future update. current default is 1.
     * @type {number}
     * @memberof Skin
     */
    version?: number;
    /**
     * base title of this content
     * @type {string}
     * @memberof Skin
     */
    title?: string;
    /**
     * something footer(ex. featuring xyz) for this content
     * @type {string}
     * @memberof Skin
     */
    subtitle?: string;
    /**
     * author of this content
     * @type {string}
     * @memberof Skin
     */
    author?: string;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    thumbnail?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    data?: SonolusResourceLocator;
    /**
     * 
     * @type {SonolusResourceLocator}
     * @memberof Skin
     */
    texture?: SonolusResourceLocator;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof Skin
     */
    updatedTime?: number;
    /**
     * 独自要素: 譜面作成者のユーザーID
     * @type {string}
     * @memberof Skin
     */
    userId?: string;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof Skin
     */
    description?: string;
}
/**
 * Sonolus Resource Locator(SRL) is used in server endpoints in order for Sonolus to locate a resource. All resources must be gzip compressed. https://github.com/NonSpicyBurrito/sonolus-wiki/wiki/Resource-and-SRL
 * @export
 * @interface SonolusResourceLocator
 */
export interface SonolusResourceLocator {
    /**
     * When specify type together with hash uniquely identifies a resource.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    type?: SonolusResourceLocatorTypeEnum;
    /**
     * Hash is calculated using SHA1 on the resource file
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    hash?: string;
    /**
     * If url starts with character /, it will be treated as relative path to server address.
     * @type {string}
     * @memberof SonolusResourceLocator
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SonolusResourceLocatorTypeEnum {
    SkinData = 'SkinData',
    EngineThumbnail = 'EngineThumbnail',
    EffectData = 'EffectData',
    SkinTexture = 'SkinTexture',
    ParticleData = 'ParticleData',
    EffectThumbnail = 'EffectThumbnail',
    LevelBgm = 'LevelBgm',
    BackgroundThumbnail = 'BackgroundThumbnail',
    EngineConfiguration = 'EngineConfiguration',
    LevelData = 'LevelData',
    ParticleTexture = 'ParticleTexture',
    BackgroundData = 'BackgroundData',
    EngineData = 'EngineData',
    BackgroundImage = 'BackgroundImage',
    LevelCover = 'LevelCover',
    SkinThumbnail = 'SkinThumbnail',
    ParticleThumbnail = 'ParticleThumbnail'
}

/**
 * ユーザー情報型
 * @export
 * @interface User
 */
export interface User {
    /**
     * FirebaseDatabase上のユーザーID
     * @type {string}
     * @memberof User
     */
    userId?: string;
    /**
     * テスト用サーバーのエンドポイント
     * @type {string}
     * @memberof User
     */
    testId?: string;
    /**
     * 管理者か否か
     * @type {boolean}
     * @memberof User
     */
    isAdmin?: boolean;
    /**
     * アカウント削除フラグ(trueで削除済み扱い)
     * @type {boolean}
     * @memberof User
     */
    isDeleted?: boolean;
    /**
     * トータル譜面数
     * @type {number}
     * @memberof User
     */
    totalFumen?: number;
    /**
     * 独自要素: データを作成したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    createdTime?: number;
    /**
     * 独自要素: データを更新したエポックミリ秒(ソート用)
     * @type {number}
     * @memberof User
     */
    updatedTime?: number;
    /**
     * 独自要素: サイト内および譜面情報欄に表示される説明文
     * @type {string}
     * @memberof User
     */
    description?: string;
}

/**
 * BackgroundsApi - axios parameter creator
 * @export
 */
export const BackgroundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定された背景情報をサーバーに登録します
         * @summary Add background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackground: async (backgroundName: string, background?: Background, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('addBackground', 'backgroundName', backgroundName)
            const localVarPath = `/backgrounds/{backgroundName}`
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(background, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された背景情報を編集します
         * @summary Edit background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBackground: async (backgroundName: string, background?: Background, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('editBackground', 'backgroundName', backgroundName)
            const localVarPath = `/backgrounds/{backgroundName}`
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(background, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground: async (backgroundName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('getBackground', 'backgroundName', backgroundName)
            const localVarPath = `/backgrounds/{backgroundName}`
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/backgrounds/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackgroundsApi - functional programming interface
 * @export
 */
export const BackgroundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackgroundsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定された背景情報をサーバーに登録します
         * @summary Add background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBackground(backgroundName: string, background?: Background, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBackground(backgroundName, background, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定された背景情報を編集します
         * @summary Edit background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editBackground(backgroundName: string, background?: Background, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editBackground(backgroundName, background, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackground(backgroundName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackground(backgroundName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackgroundList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackgroundsApi - factory interface
 * @export
 */
export const BackgroundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackgroundsApiFp(configuration)
    return {
        /**
         * 指定された背景情報をサーバーに登録します
         * @summary Add background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackground(backgroundName: string, background?: Background, options?: any): AxiosPromise<void> {
            return localVarFp.addBackground(backgroundName, background, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された背景情報を編集します
         * @summary Edit background
         * @param {string} backgroundName 
         * @param {Background} [background] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBackground(backgroundName: string, background?: Background, options?: any): AxiosPromise<void> {
            return localVarFp.editBackground(backgroundName, background, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get background
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground(backgroundName: string, options?: any): AxiosPromise<GetBackgroundResponse> {
            return localVarFp.getBackground(backgroundName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of background infos registered in this server Also it can search using query params
         * @summary Get background list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetBackgroundListResponse> {
            return localVarFp.getBackgroundList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackgroundsApi - object-oriented interface
 * @export
 * @class BackgroundsApi
 * @extends {BaseAPI}
 */
export class BackgroundsApi extends BaseAPI {
    /**
     * 指定された背景情報をサーバーに登録します
     * @summary Add background
     * @param {string} backgroundName 
     * @param {Background} [background] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public addBackground(backgroundName: string, background?: Background, options?: any) {
        return BackgroundsApiFp(this.configuration).addBackground(backgroundName, background, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された背景情報を編集します
     * @summary Edit background
     * @param {string} backgroundName 
     * @param {Background} [background] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public editBackground(backgroundName: string, background?: Background, options?: any) {
        return BackgroundsApiFp(this.configuration).editBackground(backgroundName, background, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified background info It will raise 404 if the background is not registered in this server
     * @summary Get background
     * @param {string} backgroundName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackground(backgroundName: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackground(backgroundName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of background infos registered in this server Also it can search using query params
     * @summary Get background list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundsApi
     */
    public getBackgroundList(localization?: string, page?: number, keywords?: string, options?: any) {
        return BackgroundsApiFp(this.configuration).getBackgroundList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたeffectをサーバーに登録します
         * @summary Add effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEffect: async (effectName: string, effect?: Effect, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('addEffect', 'effectName', effectName)
            const localVarPath = `/effects/{effectName}`
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたeffectを編集します
         * @summary Edit effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEffect: async (effectName: string, effect?: Effect, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('editEffect', 'effectName', effectName)
            const localVarPath = `/effects/{effectName}`
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect: async (effectName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('getEffect', 'effectName', effectName)
            const localVarPath = `/effects/{effectName}`
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/effects/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたeffectをサーバーに登録します
         * @summary Add effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEffect(effectName: string, effect?: Effect, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEffect(effectName, effect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたeffectを編集します
         * @summary Edit effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEffect(effectName: string, effect?: Effect, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEffect(effectName, effect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffect(effectName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffect(effectName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffectList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffectList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * 指定されたeffectをサーバーに登録します
         * @summary Add effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEffect(effectName: string, effect?: Effect, options?: any): AxiosPromise<void> {
            return localVarFp.addEffect(effectName, effect, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたeffectを編集します
         * @summary Edit effect
         * @param {string} effectName 
         * @param {Effect} [effect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEffect(effectName: string, effect?: Effect, options?: any): AxiosPromise<void> {
            return localVarFp.editEffect(effectName, effect, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get effect
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffect(effectName: string, options?: any): AxiosPromise<GetEffectResponse> {
            return localVarFp.getEffect(effectName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of effect infos registered in this server Also it can search using query params
         * @summary Get effect list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEffectListResponse> {
            return localVarFp.getEffectList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * 指定されたeffectをサーバーに登録します
     * @summary Add effect
     * @param {string} effectName 
     * @param {Effect} [effect] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public addEffect(effectName: string, effect?: Effect, options?: any) {
        return EffectsApiFp(this.configuration).addEffect(effectName, effect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたeffectを編集します
     * @summary Edit effect
     * @param {string} effectName 
     * @param {Effect} [effect] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public editEffect(effectName: string, effect?: Effect, options?: any) {
        return EffectsApiFp(this.configuration).editEffect(effectName, effect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified effect info It will raise 404 if the effect is not registered in this server
     * @summary Get effect
     * @param {string} effectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffect(effectName: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffect(effectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of effect infos registered in this server Also it can search using query params
     * @summary Get effect list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public getEffectList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EffectsApiFp(this.configuration).getEffectList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたゲームエンジンをサーバーに登録します
         * @summary Add engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEngine: async (engineName: string, engine?: Engine, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('addEngine', 'engineName', engineName)
            const localVarPath = `/engines/{engineName}`
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(engine, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたengineを編集します
         * @summary Edit engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEngine: async (engineName: string, engine?: Engine, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('editEngine', 'engineName', engineName)
            const localVarPath = `/engines/{engineName}`
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(engine, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine: async (engineName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('getEngine', 'engineName', engineName)
            const localVarPath = `/engines/{engineName}`
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/engines/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnginesApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたゲームエンジンをサーバーに登録します
         * @summary Add engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEngine(engineName: string, engine?: Engine, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEngine(engineName, engine, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたengineを編集します
         * @summary Edit engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEngine(engineName: string, engine?: Engine, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEngine(engineName, engine, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngine(engineName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngine(engineName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngineList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngineList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnginesApi - factory interface
 * @export
 */
export const EnginesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnginesApiFp(configuration)
    return {
        /**
         * 指定されたゲームエンジンをサーバーに登録します
         * @summary Add engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEngine(engineName: string, engine?: Engine, options?: any): AxiosPromise<void> {
            return localVarFp.addEngine(engineName, engine, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたengineを編集します
         * @summary Edit engine
         * @param {string} engineName 
         * @param {Engine} [engine] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEngine(engineName: string, engine?: Engine, options?: any): AxiosPromise<void> {
            return localVarFp.editEngine(engineName, engine, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get engine
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngine(engineName: string, options?: any): AxiosPromise<GetEngineResponse> {
            return localVarFp.getEngine(engineName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of engine infos registered in this server Also it can search using query params
         * @summary Get engine list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEngineListResponse> {
            return localVarFp.getEngineList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnginesApi - object-oriented interface
 * @export
 * @class EnginesApi
 * @extends {BaseAPI}
 */
export class EnginesApi extends BaseAPI {
    /**
     * 指定されたゲームエンジンをサーバーに登録します
     * @summary Add engine
     * @param {string} engineName 
     * @param {Engine} [engine] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public addEngine(engineName: string, engine?: Engine, options?: any) {
        return EnginesApiFp(this.configuration).addEngine(engineName, engine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたengineを編集します
     * @summary Edit engine
     * @param {string} engineName 
     * @param {Engine} [engine] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public editEngine(engineName: string, engine?: Engine, options?: any) {
        return EnginesApiFp(this.configuration).editEngine(engineName, engine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified engine info It will raise 404 if the engine is not registered in this server
     * @summary Get engine
     * @param {string} engineName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngine(engineName: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngine(engineName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of engine infos registered in this server Also it can search using query params
     * @summary Get engine list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getEngineList(localization?: string, page?: number, keywords?: string, options?: any) {
        return EnginesApiFp(this.configuration).getEngineList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sonolusのサーバー情報欄に表示されるデータを変更します (表示したい情報をまとめてここに投げること)
         * @summary Edit server info
         * @param {ServerInfo} [serverInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editInfo: async (serverInfo?: ServerInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serverInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Sonolusのサーバー情報欄に表示されるデータを変更します (表示したい情報をまとめてここに投げること)
         * @summary Edit server info
         * @param {ServerInfo} [serverInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editInfo(serverInfo?: ServerInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editInfo(serverInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Sonolusのサーバー情報欄に表示されるデータを変更します (表示したい情報をまとめてここに投げること)
         * @summary Edit server info
         * @param {ServerInfo} [serverInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editInfo(serverInfo?: ServerInfo, options?: any): AxiosPromise<void> {
            return localVarFp.editInfo(serverInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Sonolusのサーバー情報欄に表示されるデータを変更します (表示したい情報をまとめてここに投げること)
     * @summary Edit server info
     * @param {ServerInfo} [serverInfo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public editInfo(serverInfo?: ServerInfo, options?: any) {
        return InfoApiFp(this.configuration).editInfo(serverInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns small list of all infos registered in this server (It should be trimed if the server has too many items)
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getServerInfo(options?: any) {
        return InfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LevelsApi - axios parameter creator
 * @export
 */
export const LevelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('addLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel: async (levelName: string, level?: Level, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('editLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(level, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel: async (levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevel', 'levelName', levelName)
            const localVarPath = `/levels/{levelName}`
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/levels/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LevelsApi - functional programming interface
 * @export
 */
export const LevelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LevelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLevel(levelName: string, level?: Level, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLevel(levelName, level, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevel(levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevel(levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LevelsApi - factory interface
 * @export
 */
export const LevelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LevelsApiFp(configuration)
    return {
        /**
         * 指定された譜面情報をサーバーに登録します
         * @summary Add level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.addLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたlevelを編集します
         * @summary Edit level
         * @param {string} levelName 
         * @param {Level} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLevel(levelName: string, level?: Level, options?: any): AxiosPromise<void> {
            return localVarFp.editLevel(levelName, level, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get level
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevel(levelName: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevel(levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of level infos registered in this server Also it can search using query params
         * @summary Get level list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getLevelList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LevelsApi - object-oriented interface
 * @export
 * @class LevelsApi
 * @extends {BaseAPI}
 */
export class LevelsApi extends BaseAPI {
    /**
     * 指定された譜面情報をサーバーに登録します
     * @summary Add level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public addLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).addLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたlevelを編集します
     * @summary Edit level
     * @param {string} levelName 
     * @param {Level} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public editLevel(levelName: string, level?: Level, options?: any) {
        return LevelsApiFp(this.configuration).editLevel(levelName, level, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get level
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevel(levelName: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevel(levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of level infos registered in this server Also it can search using query params
     * @summary Get level list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getLevelList(localization?: string, page?: number, keywords?: string, options?: any) {
        return LevelsApiFp(this.configuration).getLevelList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParticlesApi - axios parameter creator
 * @export
 */
export const ParticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたパーティクル情報をサーバーに登録します
         * @summary Add particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParticle: async (particleName: string, particle?: Particle, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('addParticle', 'particleName', particleName)
            const localVarPath = `/particles/{particleName}`
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(particle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したparticleを編集します
         * @summary Edit particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editParticle: async (particleName: string, particle?: Particle, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('editParticle', 'particleName', particleName)
            const localVarPath = `/particles/{particleName}`
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(particle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle: async (particleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('getParticle', 'particleName', particleName)
            const localVarPath = `/particles/{particleName}`
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/particles/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticlesApi - functional programming interface
 * @export
 */
export const ParticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたパーティクル情報をサーバーに登録します
         * @summary Add particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addParticle(particleName: string, particle?: Particle, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addParticle(particleName, particle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定したparticleを編集します
         * @summary Edit particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editParticle(particleName: string, particle?: Particle, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editParticle(particleName, particle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticle(particleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticle(particleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticleList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticleList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParticlesApi - factory interface
 * @export
 */
export const ParticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticlesApiFp(configuration)
    return {
        /**
         * 指定されたパーティクル情報をサーバーに登録します
         * @summary Add particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParticle(particleName: string, particle?: Particle, options?: any): AxiosPromise<void> {
            return localVarFp.addParticle(particleName, particle, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したparticleを編集します
         * @summary Edit particle
         * @param {string} particleName 
         * @param {Particle} [particle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editParticle(particleName: string, particle?: Particle, options?: any): AxiosPromise<void> {
            return localVarFp.editParticle(particleName, particle, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get particle
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticle(particleName: string, options?: any): AxiosPromise<GetParticleResponse> {
            return localVarFp.getParticle(particleName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of particle infos registered in this server Also it can search using query params
         * @summary Get particle list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetParticleListResponse> {
            return localVarFp.getParticleList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticlesApi - object-oriented interface
 * @export
 * @class ParticlesApi
 * @extends {BaseAPI}
 */
export class ParticlesApi extends BaseAPI {
    /**
     * 指定されたパーティクル情報をサーバーに登録します
     * @summary Add particle
     * @param {string} particleName 
     * @param {Particle} [particle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public addParticle(particleName: string, particle?: Particle, options?: any) {
        return ParticlesApiFp(this.configuration).addParticle(particleName, particle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したparticleを編集します
     * @summary Edit particle
     * @param {string} particleName 
     * @param {Particle} [particle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public editParticle(particleName: string, particle?: Particle, options?: any) {
        return ParticlesApiFp(this.configuration).editParticle(particleName, particle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified particle info It will raise 404 if the particle is not registered in this server
     * @summary Get particle
     * @param {string} particleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticle(particleName: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticle(particleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of particle infos registered in this server Also it can search using query params
     * @summary Get particle list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticlesApi
     */
    public getParticleList(localization?: string, page?: number, keywords?: string, options?: any) {
        return ParticlesApiFp(this.configuration).getParticleList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SkinsApi - axios parameter creator
 * @export
 */
export const SkinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたスキン情報をサーバーに登録します
         * @summary Add skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSkin: async (skinName: string, skin?: Skin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('addSkin', 'skinName', skinName)
            const localVarPath = `/skins/{skinName}`
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したskinを編集します
         * @summary Edit skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSkin: async (skinName: string, skin?: Skin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('editSkin', 'skinName', skinName)
            const localVarPath = `/skins/{skinName}`
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin: async (skinName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('getSkin', 'skinName', skinName)
            const localVarPath = `/skins/{skinName}`
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList: async (localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/skins/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkinsApi - functional programming interface
 * @export
 */
export const SkinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkinsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたスキン情報をサーバーに登録します
         * @summary Add skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSkin(skinName: string, skin?: Skin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSkin(skinName, skin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定したskinを編集します
         * @summary Edit skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editSkin(skinName: string, skin?: Skin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editSkin(skinName, skin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkin(skinName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkin(skinName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkinList(localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkinList(localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SkinsApi - factory interface
 * @export
 */
export const SkinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkinsApiFp(configuration)
    return {
        /**
         * 指定されたスキン情報をサーバーに登録します
         * @summary Add skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSkin(skinName: string, skin?: Skin, options?: any): AxiosPromise<void> {
            return localVarFp.addSkin(skinName, skin, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したskinを編集します
         * @summary Edit skin
         * @param {string} skinName 
         * @param {Skin} [skin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSkin(skinName: string, skin?: Skin, options?: any): AxiosPromise<void> {
            return localVarFp.editSkin(skinName, skin, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get skin
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkin(skinName: string, options?: any): AxiosPromise<GetSkinResponse> {
            return localVarFp.getSkin(skinName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns list of skin infos registered in this server Also it can search using query params
         * @summary Get skin list
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinList(localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetSkinListResponse> {
            return localVarFp.getSkinList(localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkinsApi - object-oriented interface
 * @export
 * @class SkinsApi
 * @extends {BaseAPI}
 */
export class SkinsApi extends BaseAPI {
    /**
     * 指定されたスキン情報をサーバーに登録します
     * @summary Add skin
     * @param {string} skinName 
     * @param {Skin} [skin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public addSkin(skinName: string, skin?: Skin, options?: any) {
        return SkinsApiFp(this.configuration).addSkin(skinName, skin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したskinを編集します
     * @summary Edit skin
     * @param {string} skinName 
     * @param {Skin} [skin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public editSkin(skinName: string, skin?: Skin, options?: any) {
        return SkinsApiFp(this.configuration).editSkin(skinName, skin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified skin info It will raise 404 if the skin is not registered in this server
     * @summary Get skin
     * @param {string} skinName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkin(skinName: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkin(skinName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns list of skin infos registered in this server Also it can search using query params
     * @summary Get skin list
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkinsApi
     */
    public getSkinList(localization?: string, page?: number, keywords?: string, options?: any) {
        return SkinsApiFp(this.configuration).getSkinList(localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestsApi - axios parameter creator
 * @export
 */
export const TestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get testing background
         * @param {string} testId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundTest: async (testId: string, backgroundName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getBackgroundTest', 'testId', testId)
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('getBackgroundTest', 'backgroundName', backgroundName)
            const localVarPath = `/tests/{testId}/backgrounds/{backgroundName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get testing effect
         * @param {string} testId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectTest: async (testId: string, effectName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getEffectTest', 'testId', testId)
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('getEffectTest', 'effectName', effectName)
            const localVarPath = `/tests/{testId}/effects/{effectName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get testing engine
         * @param {string} testId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineTest: async (testId: string, engineName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getEngineTest', 'testId', testId)
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('getEngineTest', 'engineName', engineName)
            const localVarPath = `/tests/{testId}/engines/{engineName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest: async (testId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getLevelTest', 'testId', testId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getLevelTest', 'levelName', levelName)
            const localVarPath = `/tests/{testId}/levels/{levelName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get testing particle
         * @param {string} testId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleTest: async (testId: string, particleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getParticleTest', 'testId', testId)
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('getParticleTest', 'particleName', particleName)
            const localVarPath = `/tests/{testId}/particles/{particleName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get testing skin
         * @param {string} testId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinTest: async (testId: string, skinName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getSkinTest', 'testId', testId)
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('getSkinTest', 'skinName', skinName)
            const localVarPath = `/tests/{testId}/skins/{skinName}`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)))
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo: async (testId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestServerInfo', 'testId', testId)
            const localVarPath = `/tests/{testId}/info`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get backgrounds for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsBackgrounds: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsBackgrounds', 'testId', testId)
            const localVarPath = `/tests/{testId}/backgrounds/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ エフェクト一覧を返す(一般のエフェクトリストと同じのが返される)
         * @summary Get effects for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsEffects: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsEffects', 'testId', testId)
            const localVarPath = `/tests/{testId}/effects/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ エンジン一覧を返す(一般のエンジンリストと同じのが返される)
         * @summary Get engines for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsEngines: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsEngines', 'testId', testId)
            const localVarPath = `/tests/{testId}/engines/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsLevels', 'testId', testId)
            const localVarPath = `/tests/{testId}/levels/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ パーティクル一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get particles for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsParticles: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsParticles', 'testId', testId)
            const localVarPath = `/tests/{testId}/particles/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 譜面テスト用エンドポイント/ スキン一覧を返す(一般のスキンリストと同じのが返される)
         * @summary Get skins for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsSkins: async (testId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getTestsSkins', 'testId', testId)
            const localVarPath = `/tests/{testId}/skins/list`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestsApi - functional programming interface
 * @export
 */
export const TestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestsApiAxiosParamCreator(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get testing background
         * @param {string} testId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackgroundTest(testId: string, backgroundName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackgroundTest(testId, backgroundName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get testing effect
         * @param {string} testId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffectTest(testId: string, effectName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffectTest(testId, effectName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get testing engine
         * @param {string} testId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngineTest(testId: string, engineName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngineTest(testId, engineName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelTest(testId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLevelTest(testId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get testing particle
         * @param {string} testId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticleTest(testId: string, particleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticleTest(testId, particleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get testing skin
         * @param {string} testId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSkinTest(testId: string, skinName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSkinTest(testId, skinName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestServerInfo(testId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestServerInfo(testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get backgrounds for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsBackgrounds(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsBackgrounds(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ エフェクト一覧を返す(一般のエフェクトリストと同じのが返される)
         * @summary Get effects for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsEffects(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsEffects(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ エンジン一覧を返す(一般のエンジンリストと同じのが返される)
         * @summary Get engines for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsEngines(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsEngines(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsLevels(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ パーティクル一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get particles for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsParticles(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsParticles(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 譜面テスト用エンドポイント/ スキン一覧を返す(一般のスキンリストと同じのが返される)
         * @summary Get skins for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestsSkins(testId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestsSkins(testId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestsApi - factory interface
 * @export
 */
export const TestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestsApiFp(configuration)
    return {
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get testing background
         * @param {string} testId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackgroundTest(testId: string, backgroundName: string, options?: any): AxiosPromise<GetBackgroundResponse> {
            return localVarFp.getBackgroundTest(testId, backgroundName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get testing effect
         * @param {string} testId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffectTest(testId: string, effectName: string, options?: any): AxiosPromise<GetEffectResponse> {
            return localVarFp.getEffectTest(testId, effectName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get testing engine
         * @param {string} testId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineTest(testId: string, engineName: string, options?: any): AxiosPromise<GetEngineResponse> {
            return localVarFp.getEngineTest(testId, engineName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get testing level
         * @param {string} testId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelTest(testId: string, levelName: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getLevelTest(testId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get testing particle
         * @param {string} testId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticleTest(testId: string, particleName: string, options?: any): AxiosPromise<GetParticleResponse> {
            return localVarFp.getParticleTest(testId, particleName, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get testing skin
         * @param {string} testId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSkinTest(testId: string, skinName: string, options?: any): AxiosPromise<GetSkinResponse> {
            return localVarFp.getSkinTest(testId, skinName, options).then((request) => request(axios, basePath));
        },
        /**
         * テスト個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestServerInfo(testId: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getTestServerInfo(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get backgrounds for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsBackgrounds(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetBackgroundListResponse> {
            return localVarFp.getTestsBackgrounds(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ エフェクト一覧を返す(一般のエフェクトリストと同じのが返される)
         * @summary Get effects for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsEffects(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEffectListResponse> {
            return localVarFp.getTestsEffects(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ エンジン一覧を返す(一般のエンジンリストと同じのが返される)
         * @summary Get engines for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsEngines(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEngineListResponse> {
            return localVarFp.getTestsEngines(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getTestsLevels(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ パーティクル一覧を返す(一般の背景リストと同じのが返される)
         * @summary Get particles for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsParticles(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetParticleListResponse> {
            return localVarFp.getTestsParticles(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * 譜面テスト用エンドポイント/ スキン一覧を返す(一般のスキンリストと同じのが返される)
         * @summary Get skins for test
         * @param {string} testId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestsSkins(testId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetSkinListResponse> {
            return localVarFp.getTestsSkins(testId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestsApi - object-oriented interface
 * @export
 * @class TestsApi
 * @extends {BaseAPI}
 */
export class TestsApi extends BaseAPI {
    /**
     * It returns specified background info It will raise 404 if the background is not registered in this server
     * @summary Get testing background
     * @param {string} testId 
     * @param {string} backgroundName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getBackgroundTest(testId: string, backgroundName: string, options?: any) {
        return TestsApiFp(this.configuration).getBackgroundTest(testId, backgroundName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified effect info It will raise 404 if the effect is not registered in this server
     * @summary Get testing effect
     * @param {string} testId 
     * @param {string} effectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getEffectTest(testId: string, effectName: string, options?: any) {
        return TestsApiFp(this.configuration).getEffectTest(testId, effectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified engine info It will raise 404 if the engine is not registered in this server
     * @summary Get testing engine
     * @param {string} testId 
     * @param {string} engineName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getEngineTest(testId: string, engineName: string, options?: any) {
        return TestsApiFp(this.configuration).getEngineTest(testId, engineName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get testing level
     * @param {string} testId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getLevelTest(testId: string, levelName: string, options?: any) {
        return TestsApiFp(this.configuration).getLevelTest(testId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified particle info It will raise 404 if the particle is not registered in this server
     * @summary Get testing particle
     * @param {string} testId 
     * @param {string} particleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getParticleTest(testId: string, particleName: string, options?: any) {
        return TestsApiFp(this.configuration).getParticleTest(testId, particleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified skin info It will raise 404 if the skin is not registered in this server
     * @summary Get testing skin
     * @param {string} testId 
     * @param {string} skinName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getSkinTest(testId: string, skinName: string, options?: any) {
        return TestsApiFp(this.configuration).getSkinTest(testId, skinName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * テスト個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestServerInfo(testId: string, options?: any) {
        return TestsApiFp(this.configuration).getTestServerInfo(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ 背景一覧を返す(一般の背景リストと同じのが返される)
     * @summary Get backgrounds for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsBackgrounds(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsBackgrounds(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ エフェクト一覧を返す(一般のエフェクトリストと同じのが返される)
     * @summary Get effects for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsEffects(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsEffects(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ エンジン一覧を返す(一般のエンジンリストと同じのが返される)
     * @summary Get engines for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsEngines(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsEngines(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsLevels(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsLevels(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ パーティクル一覧を返す(一般の背景リストと同じのが返される)
     * @summary Get particles for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsParticles(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsParticles(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 譜面テスト用エンドポイント/ スキン一覧を返す(一般のスキンリストと同じのが返される)
     * @summary Get skins for test
     * @param {string} testId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTestsSkins(testId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return TestsApiFp(this.configuration).getTestsSkins(testId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (userId: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('editUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserServerInfo', 'userId', userId)
            const localVarPath = `/users/{userId}/info`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get users background
         * @param {string} userId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersBackground: async (userId: string, backgroundName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersBackground', 'userId', userId)
            // verify required parameter 'backgroundName' is not null or undefined
            assertParamExists('getUsersBackground', 'backgroundName', backgroundName)
            const localVarPath = `/users/{userId}/backgrounds/{backgroundName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"backgroundName"}}`, encodeURIComponent(String(backgroundName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get backgrounds for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersBackgrounds: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersBackgrounds', 'userId', userId)
            const localVarPath = `/users/{userId}/backgrounds/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get users effect
         * @param {string} userId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEffect: async (userId: string, effectName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersEffect', 'userId', userId)
            // verify required parameter 'effectName' is not null or undefined
            assertParamExists('getUsersEffect', 'effectName', effectName)
            const localVarPath = `/users/{userId}/effects/{effectName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"effectName"}}`, encodeURIComponent(String(effectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ エフェクト一覧を返す
         * @summary Get effects for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEffects: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersEffects', 'userId', userId)
            const localVarPath = `/users/{userId}/effects/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get users engine
         * @param {string} userId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEngine: async (userId: string, engineName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersEngine', 'userId', userId)
            // verify required parameter 'engineName' is not null or undefined
            assertParamExists('getUsersEngine', 'engineName', engineName)
            const localVarPath = `/users/{userId}/engines/{engineName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"engineName"}}`, encodeURIComponent(String(engineName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ エンジン一覧を返す
         * @summary Get engines for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEngines: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersEngines', 'userId', userId)
            const localVarPath = `/users/{userId}/engines/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel: async (userId: string, levelName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevel', 'userId', userId)
            // verify required parameter 'levelName' is not null or undefined
            assertParamExists('getUsersLevel', 'levelName', levelName)
            const localVarPath = `/users/{userId}/levels/{levelName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"levelName"}}`, encodeURIComponent(String(levelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersLevels', 'userId', userId)
            const localVarPath = `/users/{userId}/levels/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get users particle
         * @param {string} userId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParticle: async (userId: string, particleName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersParticle', 'userId', userId)
            // verify required parameter 'particleName' is not null or undefined
            assertParamExists('getUsersParticle', 'particleName', particleName)
            const localVarPath = `/users/{userId}/particles/{particleName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"particleName"}}`, encodeURIComponent(String(particleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ パーティクル一覧を返す
         * @summary Get particles for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParticles: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersParticles', 'userId', userId)
            const localVarPath = `/users/{userId}/particles/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get users skin
         * @param {string} userId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSkin: async (userId: string, skinName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersSkin', 'userId', userId)
            // verify required parameter 'skinName' is not null or undefined
            assertParamExists('getUsersSkin', 'skinName', skinName)
            const localVarPath = `/users/{userId}/skins/{skinName}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skinName"}}`, encodeURIComponent(String(skinName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー個別用エンドポイント/ スキン一覧を返す
         * @summary Get skins for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSkins: async (userId: string, localization?: string, page?: number, keywords?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersSkins', 'userId', userId)
            const localVarPath = `/users/{userId}/skins/list`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (localization !== undefined) {
                localVarQueryParameter['localization'] = localization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(userId: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserServerInfo(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserServerInfo(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get users background
         * @param {string} userId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersBackground(userId: string, backgroundName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersBackground(userId, backgroundName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get backgrounds for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersBackgrounds(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackgroundListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersBackgrounds(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get users effect
         * @param {string} userId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersEffect(userId: string, effectName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersEffect(userId, effectName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ エフェクト一覧を返す
         * @summary Get effects for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersEffects(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEffectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersEffects(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get users engine
         * @param {string} userId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersEngine(userId: string, engineName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersEngine(userId, engineName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ エンジン一覧を返す
         * @summary Get engines for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersEngines(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEngineListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersEngines(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevel(userId: string, levelName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevel(userId, levelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLevelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLevels(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get users particle
         * @param {string} userId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersParticle(userId: string, particleName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersParticle(userId, particleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ パーティクル一覧を返す
         * @summary Get particles for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersParticles(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParticleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersParticles(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get users skin
         * @param {string} userId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSkin(userId: string, skinName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSkin(userId, skinName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー個別用エンドポイント/ スキン一覧を返す
         * @summary Get skins for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSkins(userId: string, localization?: string, page?: number, keywords?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSkinListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSkins(userId, localization, page, keywords, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 指定したuser情報を編集します
         * @summary Edit user
         * @param {string} userId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId: string, user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.editUser(userId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したユーザー情報を取得します
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * サーバーに登録されたユーザー一覧を返します
         * @summary Get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserList(options?: any): AxiosPromise<GetUserListResponse> {
            return localVarFp.getUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別の情報一覧を返します
         * @summary Get user server info
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserServerInfo(userId: string, options?: any): AxiosPromise<ServerInfo> {
            return localVarFp.getUserServerInfo(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified background info It will raise 404 if the background is not registered in this server
         * @summary Get users background
         * @param {string} userId 
         * @param {string} backgroundName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersBackground(userId: string, backgroundName: string, options?: any): AxiosPromise<GetBackgroundResponse> {
            return localVarFp.getUsersBackground(userId, backgroundName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get backgrounds for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersBackgrounds(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetBackgroundListResponse> {
            return localVarFp.getUsersBackgrounds(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified effect info It will raise 404 if the effect is not registered in this server
         * @summary Get users effect
         * @param {string} userId 
         * @param {string} effectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEffect(userId: string, effectName: string, options?: any): AxiosPromise<GetEffectResponse> {
            return localVarFp.getUsersEffect(userId, effectName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ エフェクト一覧を返す
         * @summary Get effects for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEffects(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEffectListResponse> {
            return localVarFp.getUsersEffects(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified engine info It will raise 404 if the engine is not registered in this server
         * @summary Get users engine
         * @param {string} userId 
         * @param {string} engineName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEngine(userId: string, engineName: string, options?: any): AxiosPromise<GetEngineResponse> {
            return localVarFp.getUsersEngine(userId, engineName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ エンジン一覧を返す
         * @summary Get engines for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersEngines(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetEngineListResponse> {
            return localVarFp.getUsersEngines(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified level info It will raise 404 if the level is not registered in this server
         * @summary Get users level
         * @param {string} userId 
         * @param {string} levelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevel(userId: string, levelName: string, options?: any): AxiosPromise<GetLevelResponse> {
            return localVarFp.getUsersLevel(userId, levelName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ 背景一覧を返す
         * @summary Get levels for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetLevelListResponse> {
            return localVarFp.getUsersLevels(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified particle info It will raise 404 if the particle is not registered in this server
         * @summary Get users particle
         * @param {string} userId 
         * @param {string} particleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParticle(userId: string, particleName: string, options?: any): AxiosPromise<GetParticleResponse> {
            return localVarFp.getUsersParticle(userId, particleName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ パーティクル一覧を返す
         * @summary Get particles for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParticles(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetParticleListResponse> {
            return localVarFp.getUsersParticles(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns specified skin info It will raise 404 if the skin is not registered in this server
         * @summary Get users skin
         * @param {string} userId 
         * @param {string} skinName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSkin(userId: string, skinName: string, options?: any): AxiosPromise<GetSkinResponse> {
            return localVarFp.getUsersSkin(userId, skinName, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー個別用エンドポイント/ スキン一覧を返す
         * @summary Get skins for test
         * @param {string} userId 
         * @param {string} [localization] It localizes response items if possible
         * @param {number} [page] It filters items for pagination if possible
         * @param {string} [keywords] It filters items for search from list if possible
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSkins(userId: string, localization?: string, page?: number, keywords?: string, options?: any): AxiosPromise<GetSkinListResponse> {
            return localVarFp.getUsersSkins(userId, localization, page, keywords, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 指定したuser情報を編集します
     * @summary Edit user
     * @param {string} userId 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editUser(userId: string, user?: User, options?: any) {
        return UsersApiFp(this.configuration).editUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したユーザー情報を取得します
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * サーバーに登録されたユーザー一覧を返します
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserList(options?: any) {
        return UsersApiFp(this.configuration).getUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別の情報一覧を返します
     * @summary Get user server info
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserServerInfo(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUserServerInfo(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified background info It will raise 404 if the background is not registered in this server
     * @summary Get users background
     * @param {string} userId 
     * @param {string} backgroundName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersBackground(userId: string, backgroundName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersBackground(userId, backgroundName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ 背景一覧を返す
     * @summary Get backgrounds for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersBackgrounds(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersBackgrounds(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified effect info It will raise 404 if the effect is not registered in this server
     * @summary Get users effect
     * @param {string} userId 
     * @param {string} effectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersEffect(userId: string, effectName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersEffect(userId, effectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ エフェクト一覧を返す
     * @summary Get effects for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersEffects(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersEffects(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified engine info It will raise 404 if the engine is not registered in this server
     * @summary Get users engine
     * @param {string} userId 
     * @param {string} engineName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersEngine(userId: string, engineName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersEngine(userId, engineName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ エンジン一覧を返す
     * @summary Get engines for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersEngines(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersEngines(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified level info It will raise 404 if the level is not registered in this server
     * @summary Get users level
     * @param {string} userId 
     * @param {string} levelName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevel(userId: string, levelName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevel(userId, levelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ 背景一覧を返す
     * @summary Get levels for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersLevels(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersLevels(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified particle info It will raise 404 if the particle is not registered in this server
     * @summary Get users particle
     * @param {string} userId 
     * @param {string} particleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersParticle(userId: string, particleName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersParticle(userId, particleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ パーティクル一覧を返す
     * @summary Get particles for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersParticles(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersParticles(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns specified skin info It will raise 404 if the skin is not registered in this server
     * @summary Get users skin
     * @param {string} userId 
     * @param {string} skinName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersSkin(userId: string, skinName: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersSkin(userId, skinName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー個別用エンドポイント/ スキン一覧を返す
     * @summary Get skins for test
     * @param {string} userId 
     * @param {string} [localization] It localizes response items if possible
     * @param {number} [page] It filters items for pagination if possible
     * @param {string} [keywords] It filters items for search from list if possible
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersSkins(userId: string, localization?: string, page?: number, keywords?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersSkins(userId, localization, page, keywords, options).then((request) => request(this.axios, this.basePath));
    }
}


